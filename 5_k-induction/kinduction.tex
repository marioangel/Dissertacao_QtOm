%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Avaliação experimental}
\label{sec:dis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Este capítulo é dividido em três partes. Seção~\ref{sec:setup} descreve toda configuração experimental utilizada, os experimentos e todos os parâmetros de avaliação utilizados para a realização das avaliações. Na seção~\ref{sec:benchmark}, a corretude e também o desempenho da metodologia proposta são verificados, utilizando programas Qt/C++ \textit{single-thread} baseados na documentação do \textit{framework} multiplataforma Qt~\cite{Qt15}. Por fim, é descrito na seção~\ref{sec:realqt} os resultados da verificação para as duas aplicações reais (Locomaps~\cite{locomaps} e GeoMessage~\cite{geomessage}) utilizando o modelo operacional proposto denominado QtOM.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Configuração Experimental}
\label{sec:setup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Com o intuito de avaliar a eficácia da abordagem proposta a cerca da verificação de programas que utilizam o \textit{framework} Qt, um conjunto de testes automáticos denomidado \textit{esbmc--qt} foi criado. Em resumo, neste conjunto de testes contém $711$ programas Qt/C++ ($12903$ linhas de código), ou seja, todos os casos de teste utilizadas na atual avaliação.

Os casos de teste mencionados acima estão dividos em 10 principais conjuntos de teste, denominados QHash, QLinkedList, QList, QMap, QMultiHash, QMultiMap, QQueue, QSet, QStack e QVector. Vale ressaltar que todos os conjuntos de teste criados possuem casos de teste de acordo com a respectiva classe container a ser analisada (\textit{e.g}, conjunto de teste QHash possui casos de testes que foram utilizados para avaliar o processo de verificação da classe \textit{container QHash} pertencente ao \textit{framework} multiplataforma Qt) que em sua maioria possuem acesso aos módulos \textit{Qt Core} e \textit{Qt GUI}. Alguns casos de teste foram desenvolvidos a partir da documentação referente ao \textit{framework} analisado e os restantes foram desenvolvidos especificamente para analisar todas as característica fornecidas pelo \textit{framework}. Além disso, cada caso de teste é verificado manualmente antes de ser adicionado ao seu respectivo conjunto de teste. Desta forma, é capaz de se identificar se um determinado caso de teste possui ou não qualquer erro e está de acordo com a operação a ser realizada. Assim, com base nesta revisão, é possível garantir que $353$ dos $711$ casos de teste contêm erro (\textit{i.e.}, $49.65$\% do casos de teste analisados contêm erro) e $358$ casos de teste não possuem falhas (\textit{i.e.}, $50.35$\% dos casos de teste analisados são considerados corretos). Na realidade esse tipo de revisão é essencial para a nossa avaliação experimental, uma vez que pode-se comparar os resultados obtidos através da verificação realizada pelas ferramentas de verificação utilizadas e avaliar adequadamente se erros reais foram encontrados. 

Todos os experimentos foram realizados em um computador Intel Core $i7$-$4790$ com $3.60$ GHz de clock e $24$ GB ($22$ GB de memória RAM e $2$ GB de mémoria virtual), utilizando-se um sistema operacional \textit{open source} de $64$ bits denominado Fedora. Além disso, também se utilizou a ferramenta de verificação ESBMC$++$~$v1.25.4$ com três tipos de solucionadores SMT instalados (Z3~$v4.0$, Boolector~$v2.0.1$ e Yices 2~$v4.1$). Os limites de tempo e memória utilizados para cada caso de teste foram respectivamente definidos em 600 segundos e 22 GB. Por fim, uma avaliação foi realizada utilizando CBMC~$v5.1$, LLBMC~$v2013.1$ e DIVINE~$v3.3.2$ combinados com o modelo operacinal proposto (QtOM) com o objetivo de proporcionar comparações entre ferramentas. Os períodos de tempo foram indicados usando a função \verb|clock_gettime| a partir da biblioteca \verb|time.h|~\cite{time}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Comparação entre solucionadores SMT}
\label{sec:benchmark}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

É conhecido que diferentes solucionadores SMT podem afetar fortemente os resultados obtidos, uma vez que não existe homogeneidade em relação a abordagem de implementação e as lógicas suportadas. Primeiramente foram realizadas verificações usando os três solucionadores SMT mencionadas(Z3, Boolector e Yices). Sendo assim, Yices obteve os piores resultados, apresentando uma taxa de cobertura com $78$\% e um tempo de verificação com $26,27$ minutos. Por outro lado, tanto os solucionadores Z3 e Boolector apresentaram uma taxa de cobertura com $89$\% mas as verificações realizadas com Z3 se mostraram inferiores em relação as verificações feitas com Boolector a cerca do tempo de verificação, onde, respectivamente são apresentados tempos de verificação com $223,6$ minutos e $26,38$ minutos, sendo relatado quatro casos de teste com violação em relação ao tempo limite determinado, isto é, Boolector foi aproximadamente 8,5 vezes mais rápido que Z3 com a mesma precisão. Além disso, Yices apresentou a menor taxa de cobertura e tempo, pois, não possui suporte a tuplas. Desta forma, não conseguiu resolver corretamente as fórmulas SMT originadas do processo de verificação dos diversos casos de teste. Em resumo, de acordo com a figura ~\ref{figure:solver-comparison} Boolector se apresenta como o melhor solucionador para o processo de verificação proposto.

\begin{figure}[htb]
\centering
\subfloat[Taxa de cobertura]{
\includegraphics[width=0.45\textwidth]{figuras/qt-coverage.pdf}
\label{subfig-1:coverage}
}
\quad %espaco separador
\subfloat[Tempo de verificação]{
\includegraphics[width=0.45\textwidth]{figuras/qt-time.pdf}
\label{subfig-2:time}
}
\caption{Comparação entre solucionadores SMT.}
\label{figure:solver-comparison}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Verificação dos resultados para o conjunto de casos de teste desenvolvidos}
\label{sec:evaluation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Todos os casos de teste presente na suite de teste {\it esbmc-qt} foram verificados de forma automática por ESBMC$++$ com o objetivo de analisar a sua corretude e eficiência. Além da comparação entre solucionadores SMT descrita acima, uma análise a cerca do desempenho entre ferramentas de verificação distintas também foi realizada. Como já mencionado não existe um verificador que análise o framework Qt e nem um modelo operacional semelhante ao proposto neste trabalho(QtOM) utilizando a linguagem C++. No entanto, devido à versatilidade de QtOM também é possível conectá-lo ao processo de verificação de LLBMC~\cite{Florian12} e DIVINE~\cite{BBH13}, cuja base deste processo é a tradução código fonte em um representação intermediária denominada LLVM. Dessa forma, QtOM é usado como um apoio em seus processos de tradução, pois, o bitcode que logo em seguida é produzido contém informações a cerca do código fonte utilizado na verificação e do modelo operacional proposto(QtOM). Por fim, foi feito uma comparação em relação ao desempenho de LLBMC e ESBMC++, que são verificadores baseados em técnicas SMT, e DIVINE, que emprega uma verificação de modelos através estados explícitos. Inicialmente, houve uma iniciativa de se realizar também uma comparação com CBMC~\cite{CBMC14} embora mesmo sendo utilizado o modelo operacional proposto não foi possível de realizar as verificações determinadas, isto já havia sido relatado em trabalhos anteriores por Ramalho et al.~\cite{ECBS13} e Merz et al.~\cite{Florian12}, o que ocasionou em sua remoção durante o processo de avaliação.

As ferramentas utilizadas foram executadas seguindo três roteiros. Um para ESBMC$++$ que identifica a partir de um arquivo seus parâmetros iniciais e realiza sua execução\footnote{esbmc *.cpp -\/-unwind $<$bound$>$  -\/-no-unwinding-assertions -I /home/libraries/ {\tt-\tt-}memlimit 14000000 {\tt-\tt-}timeout 600}, outro para LLBMC que usando CLang\footnote{/usr/bin/clang++ -c -g -emit-llvm *.cpp -fno-exceptions}~\cite{CLANG} compila o código fonte desejado criando seu \textit{bitcode} e logo em seguida, também a partir de um arquivo identifica seus parâmetros iniciais e realiza a sua execução da ferramenta\footnote{llbmc *.cpp --ignore-missing-function-bodies --max-loop-iterations=$<$bound$>$ --no-max-loop-iterations-checks} e outro para DIVINE que também pré-compila os códigos fontes em C++ desejados criando seus respectivos \textit{bitcode}\footnote{divine compile --llvm -o main.bc *.cpp} e em seguida realiza a verificação sobre eles\footnote{divine verify main.bc --max-time=600 --max-memory=14000 -d}. O desdobramento de loops é definido para cada ferramenta, ou seja, o valor de $<$bound$>$ mas este valor varia entre os casos de teste. Por enquanto, LLBMC não suporta tratamento de exceção e os \textit{bitcodes} que foram criados sem exceção estavam a opção \textit{-fno-exceptions} ativa em seu compilador, se está opção estiver ativa LLBMC sempre abortará durante seu processo de verificação.

A Tabela~\ref{table:results-of-ESBMC} mostra os resultados experimentais para as combinações entre QtOM e LLBMC, DIVINE e ESBMC$++$ usando Boolector como principal solucinador SMT. \textit{CT} representa o número de programas que utilizam o framework Qt em C$++$, \textit{L} representa a quantidade total de linhas de código, \textit{Time} representa o tempo total da verificação,\textit{P} representa o número de casos de teste sem defeitos, ou seja, resultados positivos corretos, \textit{N} representa o número de casos de teste com defeitos, ou seja, resultados negativos correto, \textit{FP} representa o número falsos positivos obtidos, ou seja, a ferramenta relata programas que estão corretos como incorretos, \textit{FN} representa o número de falsos negativos obtidos, ou seja, a ferramenta relata programas incorretos como corretos e \textit{Fail} representa o número de erros internos obtidos durante a verificação(\textit{por exemplo}, erros de análise). Vale ressaltar que ESBMC++ utilizando Boolector não a estouro de memória e tempo em qualquer caso de teste utilizado.

\begin{table}[!htb]
%\begin{adjustwidth}{-0.5cm}{}
\renewcommand\arraystretch{1.18}
\setlength{\tabcolsep}{0.9pt}
\begin{center} {\small
\begin{tabular}{|l|l|r||r|r|r|r|r|r||r|r|r|r|r|r||r|r|r|r|r|r|r|}
\hline
& & & \multicolumn{6}{c||}{ESBMC++ v1.25.4}  & \multicolumn{6}{c||}{LLBMC v2013.1}  & \multicolumn{6}{c|}{DIVINE v3.3.2} \\\cline{4-21}
{\bf Testsuite}    &{\bf CT}	& {\bf L}	& {\bf Tempo} 	& {\bf P}  	& {\bf N}  	& {\bf FP} 	& {\bf FN}  & {\bf Fail}  	& {\bf Time} 	& {\bf P}  	& {\bf N}  	& {\bf FP} 	& {\bf FN}  & {\bf Fail} & {\bf Time} 	& {\bf P}  	& {\bf N}  	& {\bf FP} 	& {\bf FN}  & {\bf Fail} \\\hline
QHash 	   	& 74  	& 1170  	& 117.2   		& 33  	& 33  	& 4  		& 4	  	& 0   			& 37.13   		& 31  	& 37  	& 0  		& 6	  	& 0   		& 1432.5   	& 32  	& 33  	& 0  		& 1	  	& 8 \\ % OK
\hline
QLinkedList 	& 87 		& 1700  	& 77.0  		& 40   	& 39 		& 2   		& 2    	& 4  			& 23.3   		& 18  	& 41 		& 2	  	& 26	  	& 0  	         & 1907.6	   	& 30  	& 42  	& 1  		& 14	  	& 0    \\ % OK
\hline	
QList 		& 124  	& 2317  	& 102.1  		& 53 		& 55 		& 7   		& 9  	 	& 0  			& 19.4   		& 28  	& 56  	& 0	  	& 28	  	& 12  	& 2599.7   	& 52  	& 56  	& 0 		& 4	  	& 12    \\ % OK
\hline
QMap 		& 99  	& 1989  	& 277.2  		& 42 		& 39 		& 10   	& 8   		& 0  			& 406.4   		& 41  	& 46  	& 2  		& 8	  	& 2   		& 2109.9   	& 40  	& 44  	& 0  		& 5	  	& 10   \\ % OK
\hline 
QMultiHash 	& 24  	& 363   	& 186.4   		& 12    	& 12   	& 0   		& 0    	& 0  			& 30.8   		& 12  	& 12  	& 0  		& 0	  	& 0   		& 466.3     	& 13  	& 12  	& 0  		& 0	  	& 0   \\ % OK
\hline
QMultiMap 	& 26   	& 504   	& 136.9		& 13  	& 13   	& 0   		& 0    	& 0  			& 32.0   		& 13  	& 13  	& 0  		& 0	  	& 0   		& 549.9     	& 14  	& 13  	& 0  		& 0	  	& 0    \\ % OK
\hline
QQueue  		& 16   	& 299  	& 191  		& 8   		& 8  		& 0   		& 0    	& 0  			& 3.9   		& 8    	& 8    	& 0  		& 0	  	& 0   		& 339.7     	& 8  	        & 8    	& 0  		& 0	  	& 0    \\ % OK
\hline
QSet 		& 94   	& 1702  	& 500.5  		& 43   	& 43  	& 4  		& 4    	& 0  			& 132.6   		& 40  	& 44  	& 1  		& 5	  	& 4   		& 1897.2   	& 40  	& 41  	& 0  		& 0	  	& 13   \\ % OK
\hline
QStack 		& 12  	& 280  	& 14.5 		& 5 		& 5 		& 0  		& 0   		& 2  			& 2.2   		& 6	   	& 5    	& 1  		& 0	  	& 0   		& 262.1     	&6  	        & 6  	        	& 0  		& 0	  	& 0     \\ % OK
\hline
QVector 		& 152  	& 2582  	&157.3 		& 67  	&68  		& 7  		&8  		& 2  			& 1825.7  		& 44  	& 73  	& 0 		& 29	  	& 6    	& 3057.5   	& 68  	& 72  	& 0  		& 6	  	& 6  \\ % OK
\hline\hline
{\bf Total} 		& 708 	& 12903 	& 1760		& 316 	& 315	& 34 		& 35   	& 8  			& 2513.5  		& 241  	& 335  	& 6 		& 102	& 24  	& 14722.4   	& 303  	& 327  	& 1  		& 30	  	& 49  \\ % OK
\hline
\end{tabular} }
\end{center}
\caption{Resultados obtidos da comparação entre ESBMC++ v1.25.4 (usando Boolector como solucionador SMT), LLBMC v2013.1 e DIVINE v3.3.2.}
\label{table:results-of-ESBMC}
%\end{adjustwidth}
\end{table}
De acordo com a tabela acima, apenas $1,1$\% dos casos de teste com ESBMC$++$ alegaram falhas durante sua verificação que ocorreu quando a ferramenta não foi capaz de realizar a verificação de um determinado programa devido a erros internos enontrados. DIVINE e LLBMC apresentam taxas de falhas a cerca de $6,9$\% e $3,4$\%, respectivamente, quando tais ferramentas não conseguiram criar os \textit{bitcodes} dos programas utilizados ou durante verificação relaizada foi relatado estouro de memória ou de tempo. Em relação aos resultados $FP$, DIVINE obteve o melhor desempenho seguido por LLBMC e ESBMC$++$. Contudo, ESBMC$++$ obteve a taxa mais baixa em relação aos resultados de falsos negativso($FN$) seguido por DIVINE e por fim LLBMC, devido a forma que os iterators estão implementados no modelo operacional proposto(QtOM), através de ponteiros e vetores com o objetivo de simular seus comportamentos de forma real de acordo com o visto no capítulo~\ref{chapter:container-model}. No entanto, a estrutura criada não cobre todos os comportamentos descritos na documentação do framework. Em particular, quando uma remoção de um elemento é realizada em um container em que existe mais de um iterator apontando para ele, todos os iterators que apontam para o elemento que foi removido serão perdidos. Desta forma, este comportamento afetará as pós-condições de um programa que influenciam diretamente os resultados obtidos em relação a {\it FP} e {\it FN}. Vale ressaltar que os vetores e ponteiros têm sido extensivamente utilizados de modo a obter estruturas simples, isto é, sem classes e estruturas em sua representação o que diminui a complexidade do processo de verificação(ver seção~\ref{sec:postconditions}). Por fim, a combinação entre os resultados de ESBMC$++$ e QtOM em um verificador robusto ainda possui algumas lacunas a serem preenchidas sobre o suporte da linguagem C$++$ como descrito por Ramalho{\it et al.}~\cite{ECBS13}.

Vale mencionar que o nível de complexidade ao se verificar o código fonte de um programa aumenta de acordo com a quantidade de linhas ele tiver, assim como, a quantidade de estruturas que possuir. No entanto, de acordo como mostrado na figura~\ref{figure:time}, os conjuntos de teste \textit{QMap} e \textit{QSet} apresentam os maiores tempos durante o processo de verificação ao se utilizar ESBMC$++$, apesar de \textit{QVector} ser o mais extenso conjunto de casos de teste existente. Isso acontece devido não importar somente o número de linhas de código a ser analisado mas também a quantidade de loops presente no programa o que afeta diretamente os tempos de verificação. Na realidade, as estruturas internas do modelo operacional associadas a QMap e QSet contém mais loops do que as demais, desta forma, obtendo-se tempos de verificação mais longos. Como também visto na figura~\ref{figure:time}, LLBMC apresenta um maior tempo de verificação ao se utilizar o conjunto de teste \textit{QVector}, na qual isto ocorre devido a dois casos de teste onde houve estouro do tempo estimado para que seja realizada a verificação. Além disso, DIVINE é a ferramenta que apresenta o menor desempenho entre as citadas, pois, seu processo de criação do \textit{bitcode} é mais custoso do que a realização da verificação sobre o mesmo. Dessa forma, os conjuntos de teste com mais programas a serem analisados obtiveram os maiores tempos ao se utilizar DIVINE que no caso são {\it QVector}, {\it QList}, {\it QMap}, {\it QLinkedList} e {\it QSet}.

\begin{figure}[htb]
  \centering
  \includegraphics[width=4.5in]{figuras/Time.pdf}
  \caption{Comparação entre os tempos de verificação em relação a ESBMC++, LLBMC e DIVINE.}
  \label{figure:time}
\end{figure}

A figura~\ref{figure:coverage} mostra todos os verificadores que obtiveram uma taxa de corbetura acima de 80\% para os containers do tipo associativo. Contudo, LLBMC não se manteve com a mesma taxa ao analisar os containers do tipo sequencial. Vale ressaltar que todos os casos de teste a partir dos conjuntos de teste {\it QMultiMap} e {\it QMultiHash} foram verificados corretamente por todos os verificadores utilizados. Os conjuntos de teste {\it QHash}, {\it QMap}, e {\it QSet}, por sua vez, apresentaram uma taxa média de até $6,7$\% para resultados falsos positivos e falsos negativos, ou seja, de $3$ a $18$ casos de teste dos $267$ casos de teste devido as limitações relacionadas a representação interna dos iterators. Além disso, LLBMC e DIVINE, respectivamente, não conseguiram verificar cerca de $4,5$\% e $13,9$\% dos casos de teste dos containers associativos, ou seja, $12$ e $13$ dos $267$ casos de teste devido a falhas no processo de criação do \textit{bitcode}. Em relação aos containers do tipo sequencial, LLBMC apresentou taxas de cobertura baixas para os conjuntos de teste {\it QVector}, {\it QLinkedList} e {\it QList} cerca de $67,7$\% a $77$\%, ou seja, $84$/$117$ de $124$/$152$ dos casos de teste respectivamente, uma vez que cerca de $22,9$\% dos casos de teste($83$ dos $363$ analisados) apresentaram resultados falsos negativos devido a também a problemas com a representação interna dos iterators. Além disso, cerca de $5$\% dos casos de teste($18$ dos $363$ analisados) não haviam sido verificados por LLBMC, uma vez que não foi capaz de criar os \textit{bitcodes} desejados. ESBMC$++$ e DIVINE, por sua vez, apresentaram uma taxa de erro de no máximo de $6,6$\%, ou seja, 24 dos 363 casos de teste para os conjuntos de teste {\it QVector}, {\it QLinkedList} e {\it QList} devido a erros de análise em suas pós-condições. Além disso, todos os casos de teste dos conjuntos de teste {\it QQueue} e {\it QStack} foram verificados corretamente, com exceção de dois casos presente em {\it QStack}, pois, ao se utilizar o solucinador Boolector com a ferramenta ESBMC$++$ não foi possível obter-se uma solução para as fórmulas SMT criadas a partir deles para os casos analisados. 

\begin{figure}[htb]
  \centering
  \includegraphics[width=4.5in]{figuras/Coverage.pdf}
  \caption{Comparação entre a taxa de cobertura em relação a ESBMC++, LLBMC e DIVINE.}
  \label{figure:coverage}
\end{figure}

Os conjuntos de teste {\it QList}, {\it QMap}, {\it QVector} e {\it QSet} possuem mais resultados falsos positivos e negativos em seus teste ao se utilizar ESBMC$++$ do que as outras ferramentas. A taxa de cobertura a cerca dos casos de teste verificados corretamente se encontra em torno de $80$ a $90$\% respectivamente, o que demonstra a eficácia em relação a verificação realizada uma vez que cada caso de teste verifica características diferentes de diferentes containers.

Vale ressaltar que ESBMC$++$ foi capaz de identificar $89,3$\% dos erros nos casos de teste utilizados, ou seja, $631$ dos $708$ casos de testes utilizados possuiam erros o que demonstra também a sua eficácia. Similarmente, LLBMC e DIVINE apresentam, respectivamente, taxas com $81,4$\% e $89$\% ,isto é, $576$ e $630$ dos $708$ casos de teste utilizados possuiam erros, isso também demonstra uma boa adequação do modelo operacional proposto(QtOM) combinado com outras ferramentas de verificação. Como consequência, a metodologia proposta não apenas se limita a uma determinada ferramenta, podendo-se adaptar para aplicações específicas em que algumas abordagens são mais adequedas do que outras. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Resultados da verificação para aplicações reais que utilizam o framework Qt}
\label{sec:realqt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Dado que o conjunto de casos de teste proposto possui como objetivo verificar propriedades específicas dos módulos pertencentes ao framework Qt também é necessário incluir resultados de verificações que envolvem aplicações reais. Os parágrafos seguintes descrevem as respectivas aplicações e os resultados associados.

A aplicação chamada {\it Locomaps}~\cite{locomaps} é um exemplo de programa que utiliza o framework Qt que exibi imagens de satélite, terrenos, mapas de ruas, serviço de planejamento \textit{tiled map} e possui um integração com GPS Qt Geo. Utilizando o mesmo código fonte está aplicação pode ser compilada e executada nos principais sistemas operacionais existentes(Mac OS X, Linux e Windows). Está aplicação possui duas classes com 115 linhas de códigos utilizando Qt/C$++$ e usando cinco APIs diferentes do framework Qt( {\it QApplication}, {\it QCoreApplication}, {\it QDesktopWidget}, {\it QtDeclarative} e {\it QMainWindow}). Vale mencionar que o código escrito em Qt/C$++$ desta aplicação, as APIs e as bibliotecas utilizadas são considerados no processo de verificação, assim como, as propriedades relacionadas a eles. 

ArcGIS~\cite{ArcGIS} para as forças armadas é um plataforma geográfica que é utilizada para criar, organizar e compartilhar materiais geográficos com usuário que utilizam mapas inteligentes online. A partir disso, GeoMessage Simulator~\cite{geomessage} possui como entrada de dados arquivos XML e cria em diferentes frequências datagramas utilizando o protocolo de datagramas por usuário(\textit{em ingles}, User Datagram Protocol(UDP)) para aplicações ArcGIS e componentes do sistema. {\it GeoMessage} também é uma aplicação multi-plataforma que contém $1209$ linhas de códigos em Qt/C++ que utiliza $20$ diferentes APIs do framework Qt englobando várias características, tais como o sistema de eventos de Qt, strings, manipulação de arquivos, widgets e assim por diante. Vale ressaltar que {\it GeoMessage} usa duas classes, {\it QMutex} e {\it QMutexLocker}, relacionadas ao módulo Qt Threading que possui classes para programas concorrentes. Tais classes foram utilizados na aplicação para travar ou destravar mutexes e o mais importante ESBMC$++$ é capaz de verificar adequadamente esses tipos de estruturas. No entanto, o modelo operacional proposto(QtOM) não fornece um suporte completo para o módulo Qt Threading ainda.

ESBMC$++$ junto ao modelo operacional proposto(QtOM) foi aplicado para verificar as aplicações {\it Locomaps} e {\it GeoMessage} buscando verificar as seguintes propriedades: violação dos limites de um array, aritméticas de under- e overflow, divisão por zero, segurança de ponteiro e outras propriedades específicas do framework definicas em QtOM de acordo com cápitulo~\ref{chapter:smt-bmc}. Além disso, ESBMC$++$ foi capaz de identificar completamente o código-fonte de cada aplicação utilizando cinco diferentes módulos de QtOM para {\it Locomaps} e vinte módulos para {\it GeoMessage}, ou seja, cada módulo de QtOM usado correspondia a uma API utilizada pela aplicação que seria verificada. O processo de verificação de ambas as aplicações foi totalmente automático e a metodologia proposta levou aproximadamente $6.7$ segundos para gerar $32$ condições de verificação(\textit{em inglês}, Verification Conditional(VC)) para {\it Locomaps} e $16$ segundos para gerar $6421$ condições de verificação para {\it GeoMessage} em um comum computador de mesa. Além disso, ESBMC$++$ não relata caso haja qualquer falso negativo mas foi capaz de encontrar bugs semelhantes em ambas as aplicações, as quais foram confirmadas pelos desenvolvedores e são explicadas abaixo.

\begin{figure}[h]
\centering
\begin{minipage}{0.35\textwidth}
\begin{lstlisting}
int main(int argc, char *argv[]) {
  QApplication app(argc, argv);
  return app.exec();
}
\end{lstlisting}
\end{minipage}
\caption{Fragmento de código do arquivo principal da aplicação {\it Locomaps}.}
\label{fig:Fig6}
\end{figure}

A figura~\ref{fig:Fig6} mostra um fragmento de código retirado do principal arquivo da aplicação {\it Locomaps} que utiliza a classe {\it QApplication} que está presente no módulo {\it QtWidgets}. Nesse caso em particular, se o parâmetro $argv$ não for corretamente inicializado, logo o construtor ao ser chamado pelo objeto $app$ não é executado de forma correta acarretando em falhas na aplicação(veja a linha2, na figura~\ref{fig:Fig6}). A fim de verificar está propriedade, ESBMC$++$ analisa duas premissas em relação aos parâmetros de entrada da aplicação (veja as linhas $4$ e $5$, na figura~\ref{fig:Fig7}), avaliando-as como pré-condições. Um erro semelhante também foi encontrado na aplicação {\it GeoMessage} e uma maneira possível para corrigir  tal erro é sempre verificar, com instruções condicionais, se $argv$ e $argc$ são argumentos válidos antes de utilizalos em uma operação.

\begin{figure}[h]
\centering
\begin{minipage}{0.50\textwidth}
\begin{lstlisting}
class QApplication {
  ...
  QApplication( int & argc, char ** argv ){
  __ESBMC_assert(argc > 0, ``Invalid parameter'');
  __ESBMC_assert(argv != NULL, ``Invalid pointer'');
  this->str = argv;
  this->_size = strlen(*argv);
  ...
 }
 ...
};
\end{lstlisting}
\end{minipage}
\caption{Modelo operacional para o construstor de $QApplication$().}
\label{fig:Fig7}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Resumo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Resumo

%Outros topicos
%\input{5_k-induction/algoritmo.tex}