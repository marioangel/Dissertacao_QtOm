\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Avaliação experimental}
\label{sec:dis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Este capítulo é dividido em cinco partes. A Seção~\ref{sec:setup} descreve toda configuração experimental utilizada, os experimentos e todos os parâmetros de avaliação utilizados. Na Seção~\ref{sec:benchmark}, o desempenho e a eficácia do método proposto são analisados junto a outros solucionadores SMT (Z3, Boolector e Yices 2) utilizando programas sequenciais Qt/C$++$ baseados em \textit{The Qt Documentation}~\cite{qtdocumentation}. Na Seção~\ref{sec:evaluation} é descrito os resultados obtidos acerca da verificação de todos os casos de teste presentes na suite de teste \textit{esbmc--qt} utilizando ferramentas de verificação distintas (ESBMC$++$, LLBMC e DIVINE) com o objetivo de analisar a versatilidade e a eficácia de QtOM junto a outras abordagens de verificação. Na Seção~\ref{sec:realqt} é descrito os resultados da verificação de duas aplicações reais (\textit{Locomaps}~\cite{locomaps} e \textit{GeoMessage Simulator}~\cite{geomessage}) utilizando QtOM. Por fim, é descrito na Seção~\ref{sec:conformance} os resultados da comparação entre os comportamentos do \textit{framework} Qt em relação a QtOM com o intuito de se avaliar o nível de conformidade entre ambos.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Configuração dos Experimentos}
\label{sec:setup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Com o intuito de avaliar a eficácia do método proposto acerca da verificação de programas que utilizam o \textit{framework} Qt, foi criado um conjunto de testes automáticos denomidado \textit{esbmc--qt}. Em resumo, este conjunto de testes contém $711$ programas Qt/C$++$ ($12903$ linhas de código) baseados em \textit{The Qt Documentation}~\cite{qtdocumentation}, ou seja, todos os casos de teste utilizadas na atual avaliação.

Os casos de teste mencionados acima estão dividos em 10 principais conjuntos de teste, denominados QHash, QLinkedList, QList, QMap, QMultiHash, QMultiMap, QQueue, QSet, QStack e QVector. Vale ressaltar que todos os conjuntos de teste criados possuem casos de teste de acordo com a respectiva classe \textit{container} a ser analisada que em sua maioria possuem acesso aos módulos \textit{Qt Core} e \textit{Qt GUI} (e.g, conjunto de teste QHash possui casos de testes que foram utilizados para avaliar o processo de verificação da classe \textit{container QHash} pertencente ao \textit{framework} multiplataforma Qt). Os casos de teste foram desenvolvidos a partir da documentação referente ao \textit{framework} Qt~\cite{qtdocumentation} e como o objetivo de analisar todas as característica fornecidas pelo \textit{framework}. Além disso, cada caso de teste é verificado manualmente antes de ser adicionado ao seu respectivo conjunto de teste. Dessa forma, é capaz de se identificar se um determinado caso de teste possui ou não qualquer erro e está de acordo com a operação a ser realizada. Além do mais, é possível garantir que $353$ dos $711$ casos de teste contêm erro (\textit{i.e.}, $49.65$\% do casos de teste analisados contêm erro) e $358$ casos de teste não possuem falhas (\textit{i.e.}, $50.35$\% dos casos de teste analisados são considerados corretos). Na realidade esse tipo de inspeção sobre os casos de teste é essencial para a avaliação experimental, uma vez que pode-se comparar os resultados obtidos através da verificação realizada pelas ferramentas de verificação utilizadas e, consequentemente, avaliar adequadamente se erros reais foram encontrados. 

Todos os experimentos foram realizados em um computador Intel Core $i7$-$4790$ com $3.60$ GHz de clock e $24$ GB ($22$ GB de memória RAM e $2$ GB de mémoria virtual), utilizando-se um sistema operacional \textit{open source} de $64$ bits denominado Fedora. Além disso, também se utilizou a ferramenta de verificação ESBMC$++$~$v1.25.4$ com três tipos de solucionadores SMT instalados (Z3~$v4.0$, Boolector~$v2.0.1$ e Yices 2~$v4.1$). Os limites de tempo e memória utilizados para cada caso de teste foram definidos em 600 segundos e 22 GB, respectivamente. Por fim, uma avaliação foi realizada utilizando o CBMC~$v5.1$, LLBMC~$v2013.1$ e DIVINE~$v3.3.2$, combinados com o modelo operacional (QtOM), com o objetivo de proporcionar comparações entre ferramentas com diferentes abordagens de verificação. Os períodos de tempo foram indicados usando a função \verb|clock_gettime|, pertencente a biblioteca \verb|time.h|~\cite{time}, que tem como finalidade aferir a hora do sistema operacional utilizado no momento de sua chamada. Para se determinar os períodos de tempo, esta função foi chamada no início e no final da aplicação assim determinando o seu tempo inicial e o seu tempo final. Logo em seguida, no final da aplicação é determinado a variação entre os tempos obtidos e por fim, determinado o período de tempo em que foi executado a análise sobre a aplicação. O período de tempo é expresso em minutos (min) ou em segundos (s). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Comparação entre solucionadores SMT}
\label{sec:benchmark}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

É conhecido que diferentes solucionadores SMT podem afetar fortemente os resultados obtidos~\cite{TSE12}, uma vez que não existe homogeneidade em relação a abordagem de implementação e respectivas heurísticas. Primeiramente, as verificações que foram realizadas, utilizaram os três solucionadores SMT já mencionados (Z3, Boolector e Yices 2) com o objetivo de avaliar o desempenho e a eficácia do método proposto. Dessa forma, Yices 2 obteve os piores resultados, apresentando uma taxa de cobertura de $78$\% e um tempo de verificação de $26,27$ minutos. Além do mais, não conseguiu resolver corretamente as fórmulas SMT originadas do processo de verificação dos diversos casos de teste. Por outro lado, tanto os solucionadores Z3 quanto Boolector apresentaram uma taxa de cobertura de $89$\%, apesar do tempo de verificação obtido ao se utilizar o solucionador Z3, para realizar verificações, seja "pior" do que ao se utilizar o solucionador Boolector, onde, respectivamente, são apresentados tempos de verificação de $223,6$ minutos e $26,38$ minutos. A partir dos resultados mencionados, o solucionador Boolector mostrou-se $8,5$ vezes mais rápido do que o solucionador Z3, apesar da mesma precisão de ambos, mas quatro casos de teste relataram violações a cerca do tempo limite determinado. Além disso, o Yices 2 não conseguiu analisar completamente todos os conjuntos de teste desenvolvidos, pois não possui suporte a tuplas e consequentemente apresentando a menor taxa de cobertura e o menor tempo. Em resumo, de acordo com a Figura~\ref{figure:solver-comparison}, o Boolector se apresenta como o melhor solucionador para o processo de verificação proposto, pois apresenta em menor tempo a maior taxa de cobertura.

\begin{figure}[htb]
\centering
\subfloat[Taxa de cobertura]{
\includegraphics[width=0.43\textwidth]{figuras/qt-coverage.pdf}
\label{subfig-1:coverage}
}
\quad %espaco separador
\subfloat[Tempo de verificação]{
\includegraphics[width=0.37\textwidth]{figuras/qt-time.pdf}
\label{subfig-2:time}
}
\caption{Comparação entre solucionadores SMT.}
\label{figure:solver-comparison}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Verificação dos resultados para o \textit{esbmc--qt}}
\label{sec:evaluation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Todos os casos de teste presentes na suíte de teste \textit{esbmc--qt} foram verificados de forma automática por ESBMC$++$ com o objetivo de analisar a sua corretude e a eficácia de QtOM. Além da comparação entre solucionadores SMT descrita na Seção~\ref{sec:benchmark}, uma outra análise com o objetivo de avaliar o desempenho de QtOM junto a outras abordagens de verificação também foi realizada. Como já mencionado, não existe uma ferramenta de verificação que verifique o \textit{framework} Qt e nem um modelo operacional semelhante a QtOM utilizando a linguagem C$++$. No entanto, devido a versatilidade de QtOM, também é possível conectá-lo ao processo de verificação de outros verificadores de modelo como LLBMC~\cite{Florian12} e DIVINE~\cite{BBH13}, cuja base deste processo é a tradução do código fonte em um representação intermediária denominada LLVM. Dessa forma, QtOM é usado como apoio em seus processos de tradução, pois o \textit{bytecode} que é produzido, contém informações a cerca do código fonte utilizado na verificação e do modelo operacional (QtOM). Por fim, foi feito uma comparação em relação ao desempenho do LLBMC e ESBMC$++$, que são verificadores baseados em técnicas SMT, e DIVINE que emprega uma verificação de modelos através de estados explícitos. Inicialmente, houve uma tentativa de se realizar também uma comparação utilizando o verificador CBMC~\cite{CBMC14}, junto com o QtOM, mas devido à falhas do verificador em relação a verificação da linguagem C$++$ não foi possível realizar as verificações previstas. Isto já havia sido relatado em trabalhos anteriores por Ramalho \textit{et al.}~\cite{ECBS13} e Merz \textit{et al.}~\cite{Florian12}, o que ocasionou em sua remoção durante o processo de avaliação.

As ferramentas utilizadas foram executadas seguindo três roteiros. Um para ESBMC$++$\footnote{esbmc *.cpp -\/-unwind $<$bound$>$  -\/-no-unwinding-assertions -I /home/libraries/  -\/-memlimit 14000000 -\/-timeout 600} que identifica a partir de um arquivo seus parâmetros iniciais e realiza sua execução, outro para LLBMC que usando CLang\footnote{/usr/bin/clang++ -c -g -emit-llvm *.cpp -fno-exceptions}~\cite{CLANG} compila o código fonte desejado criando seu \textit{bytecode} e logo em seguida, também a partir de um arquivo identifica seus parâmetros iniciais e realiza a sua execução\footnote{llbmc *.cpp --ignore-missing-function-bodies --max-loop-iterations=$<$bound$>$ --no-max-loop-iterations-checks} e outro para DIVINE que também pré-compila os códigos fontes em C$++$ criando seus respectivos \textit{bytecode}\footnote{divine compile --llvm -o main.bc *.cpp} para que em seguida realize sua verificação\footnote{divine verify main.bc --max-time=600 --max-memory=14000 -d} sobre eles. O desdobramento de laços é definido para cada ferramenta, isto é, o valor de $<$\textit{bound}$>$ varia entre os casos de teste. Por enquanto, o LLBMC não suporta tratamento de exceção e os \textit{bytecodes} que foram criados estavam com a opção \textit{-fno-exceptions} ativa em seu compilador. Vale ressaltar, que se está opção estiver ativa, o LLBMC sempre abortará durante seu processo de verificação.

A Tabela~\ref{table:results-of-ESBMC} mostra os resultados experimentais para as junções entre QtOM e LLBMC, DIVINE e ESBMC$++$ usando Boolector como seu principal solucinador SMT. Vale ressaltar que o ESBMC$++$ utilizando Boolector não apresenta estouro de memória e tempo em qualquer caso de teste utilizado. \textit{TC} representa o número de programas Qt/C$++$, \textit{L} representa a quantidade total de linhas de código, \textit{Time} representa o tempo total da verificação, \textit{P} representa o número de casos de teste sem defeitos (\textit{i.e.}, resultados positivos corretos), \textit{N} representa o número de casos de teste com defeitos (\textit{i.e.}, resultados negativos corretos), \textit{FP} representa o número falsos positivos obtidos (\textit{i.e.}, a ferramenta relata programas que estão corretos como incorretos), \textit{FN} representa o número de falsos negativos obtidos (\textit{i.e.}, a ferramenta relata programas incorretos como corretos) e \textit{Fail} representa o número de erros internos obtidos durante a verificação (e.g., erros de análise).

\begin{table}[!htb]
%\begin{adjustwidth}{-0.5cm}{}
\renewcommand\arraystretch{0.95}
\setlength{\tabcolsep}{0.7pt}
\begin{center} {\small
\begin{tabular}{|l|l|r||r|r|r|r|r|r||r|r|r|r|r|r||r|r|r|r|r|r|r|}
\hline
& & & \multicolumn{6}{c||}{ESBMC$++$ v1.25.4}  & \multicolumn{6}{c||}{LLBMC v2013.1}  & \multicolumn{6}{c|}{DIVINE v3.3.2} \\\cline{4-21}
 \textbf{Suíte de teste}    &\textbf{TC}	& \textbf{L}	& \textbf{Time} 	& \textbf{P}  	& \textbf{N}  	& \textbf{FP} 	& \textbf{FN}  & \textbf{Fail}  	& \textbf{Time} 	& \textbf{P}  	& \textbf{N}  	& \textbf{FP} 	& \textbf{FN}  & \textbf{Fail} & \textbf{Time} 	& \textbf{P}  	& \textbf{N}  	& \textbf{FP} 	& \textbf{FN}  & \textbf{Fail} \\\hline
QHash 	   	& 74  	& 1170  	& 117.2   		& 33  	& 33  	& 4  		& 4	  	& 0   			& 37.13   		& 31  	& 37  	& 0  		& 6	  	& 0   		& 1432.5   	& 32  	& 33  	& 0  		& 1	  	& 8 \\ % OK
\hline
QLinkedList 	& 87 		& 1700  	& 77.0  		& 40   	& 39 		& 2   		& 2    	& 4  			& 23.3   		& 18  	& 41 		& 2	  	& 26	  	& 0  	         & 1907.6	   	& 30  	& 42  	& 1  		& 14	  	& 0    \\ % OK
\hline	
QList 		& 124  	& 2317  	& 102.1  		& 53 		& 55 		& 7   		& 9  	 	& 0  			& 19.4   		& 28  	& 56  	& 0	  	& 28	  	& 12  	& 2599.7   	& 52  	& 56  	& 0 		& 4	  	& 12    \\ % OK
\hline
QMap 		& 99  	& 1989  	& 277.2  		& 42 		& 39 		& 10   	& 8   		& 0  			& 406.4   		& 41  	& 46  	& 2  		& 8	  	& 2   		& 2109.9   	& 40  	& 44  	& 0  		& 5	  	& 10   \\ % OK
\hline 
QMultiHash 	& 24  	& 363   	& 186.4   		& 12    	& 12   	& 0   		& 0    	& 0  			& 30.8   		& 12  	& 12  	& 0  		& 0	  	& 0   		& 466.3     	& 13  	& 12  	& 0  		& 0	  	& 0   \\ % OK
\hline
QMultiMap 	& 26   	& 504   	& 136.9		& 13  	& 13   	& 0   		& 0    	& 0  			& 32.0   		& 13  	& 13  	& 0  		& 0	  	& 0   		& 549.9     	& 14  	& 13  	& 0  		& 0	  	& 0    \\ % OK
\hline
QQueue  		& 16   	& 299  	& 191  		& 8   		& 8  		& 0   		& 0    	& 0  			& 3.9   		& 8    	& 8    	& 0  		& 0	  	& 0   		& 339.7     	& 8  	        & 8    	& 0  		& 0	  	& 0    \\ % OK
\hline
QSet 		& 94   	& 1702  	& 500.5  		& 43   	& 43  	& 4  		& 4    	& 0  			& 132.6   		& 40  	& 44  	& 1  		& 5	  	& 4   		& 1897.2   	& 40  	& 41  	& 0  		& 0	  	& 13   \\ % OK
\hline
QStack 		& 12  	& 280  	& 14.5 		& 5 		& 5 		& 0  		& 0   		& 2  			& 2.2   		& 6	   	& 5    	& 1  		& 0	  	& 0   		& 262.1     	&6  	        & 6  	        	& 0  		& 0	  	& 0     \\ % OK
\hline
QVector 		& 152  	& 2582  	&157.3 		& 67  	&68  		& 7  		&8  		& 2  			& 1825.7  		& 44  	& 73  	& 0 		& 29	  	& 6    	& 3057.5   	& 68  	& 72  	& 0  		& 6	  	& 6  \\ % OK
\hline\hline
\textbf{Total} 		& 708 	& 12903 	& 1760		& 316 	& 315	& 34 		& 35   	& 8  			& 2513.5  		& 241  	& 335  	& 6 		& 102	& 24  	& 14722.4   	& 303  	& 327  	& 1  		& 30	  	& 49  \\ % OK
\hline
\end{tabular} }
\end{center}
\caption{Resultados obtidos da comparação entre ESBMC$++$ v1.25.4 (usando Boolector como solucionador SMT), LLBMC v2013.1 e DIVINE v3.3.2.}
\label{table:results-of-ESBMC}
%\end{adjustwidth}
\end{table}

De acordo com a Tabela~\ref{table:results-of-ESBMC}, apenas $1,1$\% dos casos de teste com o ESBMC$++$ alegaram falhas durante sua verificação, isto ocorre quando a ferramenta não é capaz de realizar a verificação de um determinado programa devido a erros internos encontrados. DIVINE e LLBMC apresentam taxas de falha de $6,9$\% e $3,4$\%, respectivamente, devido não conseguirem criar os \textit{bytecodes} de determinados casos de teste ou durante a verificação realizada foi relatado que houve um estouro de memória ou de tempo. Em relação aos resultados considerados falsos positivos ($FP$), DIVINE obteve o melhor desempenho seguido por LLBMC e ESBMC$++$. Contudo, ESBMC$++$ obteve a taxa mais baixa em relação aos resultados considerados falsos negativos ($FN$) seguido por DIVINE e por fim LLBMC, isso ocorre devido a forma com que os \textit{iterators} estão implementados em QtOM, por meio de ponteiros e vetores com o objetivo de simular seus comportamentos de forma real e de acordo com o visto no Capítulo~\ref{chapter:smt-bmc}. No entanto, a estrutura criada não cobre todos os comportamentos descritos na documentação do \textit{framework}~\cite{qtdocumentation}. Em particular, quando uma operação de remoção de um elemento é realizada em um \textit{container} que existe mais de um \textit{iterator} apontando para ele, todos os \textit{iterators} que apontam para o elemento que foi removido serão perdidos. Dessa forma, este comportamento afetará diretamente as pós-condições de um programa que consequentemente também influenciará nos resultados obtidos em relação a falsos positivos ($FP$) e falsos negativos ($FN$). Além do mais, vale ressaltar que vetores e ponteiros têm sido extensivamente utilizados de modo a obter estruturas mais simples, ou seja, sem classes e \textit{structs} em suas representações o que, consequentemente, diminui a complexidade do processo de verificação (ver Seção~\ref{sec:postconditions}). Por fim, os resultados da combinação entre ESBMC$++$ e QtOM gera um verificador robusto mas que ainda possui algumas lacunas a serem preenchidas a respeito do suporte a linguagem C$++$ como descrito por Ramalho \textit{et al.}~\cite{ECBS13}. Vale mencionar que o nível de complexidade ao se verificar o código fonte de um programa aumenta de acordo com a quantidade de estruturas (dados, repetição, seleção, etc.) que possuir. 

No entanto, como mostrado na Figura~\ref{figure:time}, os conjuntos de teste QMap e QSet apresentam os maiores tempos durante o processo de verificação ao se utilizar o ESBMC$++$, apesar de QVector ser o mais extenso conjunto de casos de teste existente. Isso acontece por ser analisado a quantidade de laços presente no programa e não somente o número de linhas de código que ele possui, o que afeta diretamente os tempos de verificação. Na realidade, as estruturas internas associadas ao modelo operacional das classes \textit{QMap} e \textit{QSet} contêm mais laços do que as demais, desta forma, obtém-se tempos de verificação mais longos. Como também visto na Figura~\ref{figure:time}, o LLBMC apresenta um maior tempo de verificação ao se utilizar o conjunto de teste QVector, devido a $2$ casos de teste em que houve estouro do tempo estimado para que seja realizada a verificação. Além disso, o DIVINE é a ferramenta que apresenta o menor desempenho entre as citadas, pois seu processo de criação do \textit{bytecode} é mais custoso do que a realização da verificação sobre o mesmo. Dessa forma, os conjuntos de teste com mais programas a serem analisados obtiveram os maiores tempos que no caso são QVector, QList, QMap, QLinkedList e QSet.

\begin{figure}[htb]
  \centering
  \includegraphics[width=5.5in]{figuras/Time.pdf}
  \caption{Comparação entre os tempos de verificação em relação a ESBMC$++$, LLBMC e DIVINE.}
  \label{figure:time}
\end{figure}

A Figura~\ref{figure:coverage} mostra que todos os verificadores obtiveram uma taxa de corbetura acima de 80\% para os \textit{containers} do tipo associativo. Contudo, LLBMC não se manteve com a mesma taxa ao analisar os \textit{containers} do tipo sequencial. Vale ressaltar que todos os casos de teste dos conjuntos de teste QMultiMap e QMultiHash foram verificados corretamente por todos os verificadores utilizados. Os conjuntos de teste QHash, QMap e QSet, por sua vez, apresentaram uma taxa média de $6,7$\% para resultados falsos positivos ($FP$) e falsos negativos ($FN$), ou seja, de $3$ a $18$ casos de teste dos $267$ casos de teste são considerados falsos positivos ($FP$) ou falsos negativos ($FN$) devido às limitações na representação interna dos \textit{iterators}. Além disso, LLBMC e DIVINE, respectivamente, não conseguiram verificar cerca de $4,5$\% e $13,9$\% dos casos de teste dos \textit{containers} associativos, ou seja, $12$ e $13$ dos $267$ casos de teste não podem ser verificados devido as falhas no processo de criação do \textit{bytecode}. Em relação aos \textit{containers} do tipo sequencial, LLBMC apresentou baixas taxas de cobertura para os conjuntos de teste QVector, QLinkedList e QList, taxas a cerca de $67,7$\% a $77$\%, ou seja, $84$/$117$ dos $124$/$152$ casos de teste, respectivamente. Além disso, cerca de $22,9$\% dos casos de teste, $83$ dos $363$ casos de teste analisados apresentaram resultados falsos negativos ($FN$) devido também a problemas com a representação interna dos \textit{iterators}. Vale ressaltar, que cerca de $5$\% dos casos de teste, $18$ dos $363$ casos de teste analisados não haviam sido verificados por LLBMC, uma vez que não foi capaz de criar os \textit{bytecodes} desejados. O ESBMC$++$ e DIVINE, por sua vez, apresentaram uma taxa de erro de no máximo de $6,6$\%, ou seja, $24$ dos $363$ casos de teste para os conjuntos de teste QVector, QLinkedList e QList apresentam erros de análise em suas pós-condições. Além disso, todos os casos de teste dos conjuntos de teste QQueue e QStack foram verificados corretamente, com exceção de dois casos presentes em QStack, pois ao se utilizar o Boolector com a ferramenta ESBMC$++$, não foi possível obter uma solução para as fórmulas SMT criadas para os casos analisados. 

\begin{figure}[htb]
  \centering
  \includegraphics[width=5.5in]{figuras/Coverage.pdf}
  \caption{Comparação entre a taxa de cobertura em relação a ESBMC++, LLBMC e DIVINE.}
  \label{figure:coverage}
\end{figure}

Os conjuntos de teste QList, QMap, QVector e QSet possuem mais resultados falsos positivos ($FP$) e falsos negativos ($FN$) em seus testes ao se utilizar o ESBMC$++$ do que as outras ferramentas. A taxa de cobertura a cerca dos casos de teste verificados corretamente se encontra em torno de $80$\% a $90$\%, respectivamente, o que demonstra a eficácia em relação a verificação realizada uma vez que cada caso de teste verifica características diferentes dos \textit{containers} sequenciais e associativos.

Vale ressaltar que o ESBMC$++$ foi capaz de identificar cerca de $89,3$\% dos erros nos casos de teste utilizados (\textit{i.e.}, $631$ dos $708$ casos de testes utilizados possuem erros), o que demonstra também a eficácia do método proposto. Similarmente, LLBMC e DIVINE apresentam, respectivamente, taxas com $81,4$\% e $89$\% (\textit{i.e.}, $576$ e $630$ dos $708$ casos de teste utilizados possuem erros), o que também demonstra uma boa adequação do modelo operacional (QtOM) junto a outras ferramentas de verificação. Como consequência, o método proposto não apenas se limita a uma determinada ferramenta, podendo adaptar-se para aplicações específicas em que alguma abordagem seja a mais adequeda do que outra. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Verificação dos resultados para aplicações reais}
\label{sec:realqt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Dado que o conjunto de casos de teste proposto possui como objetivo verificar propriedades específicas dos módulos pertencentes ao \textit{framework} Qt, também é necessário incluir resultados de verificações que envolvam aplicações reais. Os parágrafos seguintes descrevem as respectivas aplicações e seus resultados associados.

A aplicação chamada \textit{Locomaps}~\cite{locomaps} é um exemplo de programa que utiliza o \textit{framework} Qt e exibe imagens de satélite, terrenos, mapas de ruas, serviço de planejamento de mapas em mosaicos e possui um integração com GPS \textit{Qt Geo}. Utilizando o mesmo código fonte esta aplicação pode ser compilada e executada nos principais sistemas operacionais existentes (Mac OS X, Linux e Windows). Está aplicação possui duas classes com $115$ linhas de código no total, utilizando Qt/C$++$ e usando cinco APIs diferentes do framework Qt (\textit{QApplication}, \textit{QCoreApplication}, \textit{QDesktopWidget}, \textit{QtDeclarative} e \textit{QMainWindow}). Vale mencionar que o código escrito em Qt/C$++$ desta aplicação, as APIs e as bibliotecas utilizadas são considerados no processo de verificação, assim como, as propriedades relacionadas a eles. 

ArcGIS~\cite{ArcGIS} para as forças armadas é uma plataforma geográfica que é utilizado para criar, organizar e compartilhar materiais geográficos com usuários que utilizam mapas inteligentes \textit{online}. A partir disso, \textit{GeoMessage Simulator}~\cite{geomessage} possui como entrada de dados arquivos XML e cria em diferentes frequências datagramas utilizando o protocolo de datagramas por usuário (\textit{em inglês}, User Datagram Protocol - UDP) para aplicações ArcGIS e componentes do sistema. \textit{GeoMessage Simulator} também é uma aplicação multi-plataforma que contém $1209$ linhas de códigos em Qt/C$++$ que utiliza $20$ diferentes APIs do \textit{framework} Qt englobando várias características, tais como o sistema de eventos de Qt, \textit{strings}, manipulação de arquivos e \textit{widgets}. Vale ressaltar que \textit{GeoMessage Simulator} usa duas classes, \textit{QMutex} e \textit{QMutexLocker}, relacionadas ao módulo \textit{Qt Threading} que possui classes para programas concorrentes. Tais classes foram utilizadas na aplicação para travar ou destravar mutexes e, o mais importante, ESBMC$++$ é capaz de verificar adequadamente esses tipos de estruturas. No entanto, o modelo operacional (QtOM) ainda não fornece um suporte completo para o módulo \textit{Qt Threading}.

O ESBMC$++$ junto com QtOM foi aplicado para verificar as aplicações \textit{Locomaps} e \textit{GeoMessage Simulator} buscando verificar as seguintes propriedades: violação dos limites de um array, estouros aritméticos, divisão por zero, segurança de ponteiro e outras propriedades específicas do \textit{framework} definidas em QtOM de acordo com o Capítulo~\ref{chapter:smt-bmc}. Além disso, ESBMC$++$ foi capaz de identificar completamente o código-fonte de cada aplicação, utilizando cinco diferentes módulos de QtOM para \textit{Locomaps} e vinte módulos para \textit{GeoMessage Simulator}, ou seja, cada módulo de QtOM usado correspondia a uma API utilizada pela aplicação que seria verificada. O processo de verificação de ambas as aplicações foi totalmente automático e o método proposto levou aproximadamente $6,7$ segundos para gerar $32$ VCs para \textit{Locomaps} e $16$ segundos para gerar $6421$ VCs para \textit{GeoMessage Simulator} em um \textit{desktop} comum. Além disso, o ESBMC$++$ não relata caso haja qualquer falso negativo, mas foi capaz de encontrar bugs semelhantes em ambas as aplicações, as quais foram confirmadas pelos desenvolvedores e são explicadas abaixo.

\begin{figure}[h]
\centering
\begin{minipage}{0.60\textwidth}
\begin{lstlisting}
int main(int argc, char *argv[]) {
  QApplication app(argc, argv);
  return app.exec();
}
\end{lstlisting}
\end{minipage}
\caption{Fragmento de código do arquivo principal da aplicação \textit{Locomaps}.}
\label{fig:Fig6}
\end{figure}

A Figura~\ref{fig:Fig6} mostra um fragmento de código retirado do arquivo principal da aplicação \textit{Locomaps} que utiliza a classe \textit{QApplication} que está presente no módulo \textit{QtWidgets}. Nesse caso em particular, se o parâmetro $argv$ não for corretamente inicializado, logo o construtor ao ser chamado pelo objeto $app$ não é executado de forma correta acarretando em falhas na aplicação (veja a linha $2$, na Figura~\ref{fig:Fig6}). A fim de verificar esta propriedade, o ESBMC$++$ analisa 2 assertivas em relação aos parâmetros de entrada da aplicação (veja as linhas $4$ e $5$, na Figura~\ref{fig:Fig7}), avaliando-as como pré-condições. Um erro semelhante também foi encontrado na aplicação \textit{GeoMessage Simulator} e uma maneira possível para corrigir tal erro é sempre verificar, com instruções condicionais, se $argv$ e $argc$ são argumentos válidos antes de utiliza-las em uma operação.

\begin{figure}[h]
\centering
\begin{minipage}{0.70\textwidth}
\begin{lstlisting}
class QApplication {
  ...
  QApplication( int & argc, char ** argv ){
  __ESBMC_assert(argc > 0, ``Invalid parameter'');
  __ESBMC_assert(argv != NULL, ``Invalid pointer'');
  this->str = argv;
  this->_size = strlen(*argv);
  ...
 }
 ...
};
\end{lstlisting}
\end{minipage}
\caption{Modelo operacional para o construstor de $QApplication$().}
\label{fig:Fig7}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Verificação da conformidade de QtOM}
\label{sec:conformance}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Todos os processos, funções, APIs, ferramentas e especificações necessárias para o desenvolvimento de aplicações que utilizam o \textit{framework} Qt são descritas por \textit{The Qt Developers} em~\cite{qtdevelopers}. Na verificação de modelos, as aplicações analisadas se utilizam de funções disponibilizadas pelo ambiente de verificação criado com o objetivo de garantir a exatidão da verificação, ou seja, se obter uma análise de forma correta. Para que isso ocorra, o comportamento do sistema desenvolvido (modelo operacional) deve ser o mesmo do sistema real (\textit{framework}) analisado. 

Sendo assim, inicialmente foi realizado uma análise sobre todos os casos de testes presentes em \textit{esbmc--qt} com o objetivo de verificar a imparcialidade e a confiabilidade das aplicações utilizadas. Todos os casos de teste foram desenvolvidos utilizando a linguaguem C++ junto com as funções disponibilizadas pelo \textit{framework} Qt, onde cada implementação usa as estruturas de dados e funções presente em Qt \textit{containers}, em todas as possíveis condições e de acordo com \textit{The Qt Documentation}~\cite{qtdocumentation}. Cada caso de teste proporciona uma falha e um sucesso de acordo com a estrutura ou função empregada como mostrado na Figura~\ref{fig:CasodeTeste}. Além do mais, todos os casos de testes presentes em \textit{esbmc--qt} foram compilados e executados utilizando o ambiente de desenvolvimento do \textit{framework} Qt denominado QtCreator com o objetivo de se obter um comportamento base do \textit{framework} em relação a Qt \textit{containers}. QtCreator é um ambiente de desenvolvimento integrado (IDE) multiplataforma utilizado por desenvolvedores para criar diversas aplicações que utilizam o \textit{framework} Qt para desktops, sistemas embarcados e plataformas de dispositivos móveis. É um ambiente de desenvolvimento disponível para Linux, OS X e Windows~\cite{qtcreator}. O mesmo foi realizado com o compilador Clang junto com o modelo operacional (QtOM), cujo objetivo era de determinar o comportamento de QtOM. Clang é um compilador \textit{front end} para as linguaguens C e C++ e foi utilizado para criar o nível de conformidade referente a QtOM, pois já havia sido utilizado em testes anteriores (ver Seção~\ref{sec:evaluation}). Por fim, foi realizado a comparação entre o comportamento base do \textit{framework} Qt em relação ao comportamento do modelo operacional (QtOM) com o objetivo de analisar o nível de conformidade entre ambos. Essa comparação é mostrada seguindo o diagrama de atividade presente na Figura~\ref{fig:DigramActConf}.

\begin{figure}[htb]
  \centering
  \includegraphics[width=4.0in]{figuras/figconf.png}
  \caption{Como os casos de teste presente em \textit{esbmc--qt} estão compostos e formados.}
  \label{fig:CasodeTeste}
\end{figure}

A Figura~\ref{fig:conformance} mostra o resultado da comparação descrita anteriormente, assim como, em testes anteriores os conjuntos de testes estão divididos em \textit{containers} associativos compostos por QHash, QSet, QMap, QMultiHash e QMultiMap e \textit{containers} sequenciais compostos por QList, QQueue, QLinkedList, QStack e QVector. Vale ressaltar que por QtCreator ser o ambiente de desenvolvimento padrão do \textit{framework} Qt, obteve um nível de conformidade de 100\% em todos os conjuntos de testes que compõe \textit{esbmc--qt}, em todas as condições possíveis de acordo com \textit{The Qt Documentation}~\cite{qtdocumentation}. Entretanto, ao se analisar o comportamento obtido atráves da junção do compilador Clang com QtOM, se obtem um nível de conformidade com média de 97,827\% em todos os conjuntos de testes que compõe \textit{esbmc--qt} em todas as condições possíveis de acordo com \textit{The Qt Documentation}~\cite{qtdocumentation}.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=4.0in]{figuras/AtividadesConf.png}
  \caption{Diagrama de atividade referente a verificação da conformidade de QtOM.}
  \label{fig:DigramActConf}
\end{figure}

Ao se analisar de modo particular, os conjuntos de testes QMultiHash, QMultiMap, QQueue, QStack obtiveram um nível de 100\% de semalhança comparado aos resultados obtidos por QtCreator. O conjunto de teste QMap obteve o menor nível de semelhança de 91,919\% em relação a QtCreator, isso ocorreu devido algumas representações presente no modelo operacional possuirem erros no uso de seus  iterators o que impossibilitava o acesso de determinados dados nas estruturas representadas e nas representações que utilizam funções estáticas, na qual, havia a perda do dado utilizado na estrutura representada, QMap é considerado o conjunto de teste com o maior número de falsos positivos e negativos entres os conjuntos de teste existentes correspondendo a cerca de 8,080\% dos seus casos de teste. 

Os conjuntos de testes QHash, QLinkedList e QList, respectivamente, obtiveram níveis de semelhança de 94,667\%, 98,850\%, 97,580\%, isso ocorreu devido a problemas com a representação de iterators usadas no modelo operacional, assim como, em QMap ao se utilizar mais de um iterator no caso de teste, a referência sobre os demais iterators utilizados é perdida no momento em que se usa um iterator para acessar/modificar dados presente no \textit{container} analisado. O conjunto de teste QLinkedList é o conjunto de teste que obteve o maior nível de semelhança entre os conjuntos de teste que não obtiveram um nível de conformidade de 100\%. O conjunto de teste QSet obteve um nível de semelhança de 97,872\% em relação a QtCreator, isso ocorreu devido algumas representações possuirem problemas em suas funções estáticas havendo perda de dados nas estruturas representadas. 

Por fim, o conjunto de caso QVector considerado o maior conjunto em número de casos de teste obteve um nível de semalhança de 97,378\%, pois não foi possível realizar a representação de funções onde em suas definições tinham como objetivo realizar algum tipo de manipulação da memória como "Ajuste fino" "Melhoria no gerenciamento da memória" (e.g. a função tem como aplicabilidade armazenar ou liberar uma quantidade da memória utilizada pelo o programa para o melhor uso do \textit{container}) entre outras definições. Vale ressaltar que não é possível criar esses tipos de representação, pois não se sabe como o \textit{framework} analisado trata essas funções internamente o que impossibilita criar uma representação na linguagem base utilizada. O conjunto QVector também teve problemas relacionados a utilização de mais um iterator, assim como, os conjuntos QMap, QHash, QLinkedList e QList. Como proposta para os erros encontrados a nível de conformidade, o uso de uma estrutura que fizesse o armazenamento dos dados mesmo que de forma temporária poderia auxiliar as aplicações tanto estáticas como as que se utilizam mais de um iterator no manuseio interno dos dados vindos da aplicação, assim evitando a perda de referência em ambos os problemas encontrados.

\begin{figure}[htb]
  \centering
  \includegraphics[width=5.5in]{figuras/conformance.png}
  \caption{Comparação entre o comportamento de QtCreator e Clang+QtOM parar medir a conformidade de QtOM.}
  \label{fig:conformance}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Resumo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

De acordo com o embasamento teórico realizado pelos capítulos anteriores em relação as técnicas SMT utilizadas, o processo de verificação de ESBMC++ junto ao modelo operacional (QtOM). Neste capítulo, inicialmente foi descrito como foi construída a configuração dos experimentos realizados, com o intuito de avaliar a eficácia do método proposto acerca da verificação de programas que utilizam o \textit{framework} Qt, a partir de uma suíte de teste denomidada \textit{esbmc--qt} que contém todos os casos de teste utilizadas na atual avaliação. A suíte \textit{esbmc--qt} contém $711$ programas Qt/C$++$ que de acordo com os experimentos realizados é possível garantir que $353$ dos $711$ casos de teste contêm erro (\textit{i.e.}, $49.65$\% do casos de teste analisados contêm erro) e $358$ casos de teste não possuem falhas (\textit{i.e.}, $50.35$\% dos casos de teste analisados são considerados corretos). 

Em seguida, foi descrito como foi realizado e avaliado a comparação entre os solucionadores SMT utilizados (Z3, Boolector e Yices 2) junto com o ESBMC$++$ utilizando programas Qt/C$++$ sequenciais. Isso foi realizado, pois solucionadores SMT podem afetar fortemente os resultados obtidos, uma vez que não existe homogeneidade em relação a abordagem de implementação e respectivas heurísticas. Sendo assim, Yices 2 obteve os piores resultados, apresentando uma taxa de cobertura de $78$\% e um tempo de verificação de $26,27$ minutos. Entretanto, Z3 e Boolector apresentaram uma taxa de cobertura de $89$\% com tempos de verificação de $223,6$ minutos e $26,38$ minutos, respectivamente. Por fim, Boolector mostrou-se $8,5$ vezes mais rápido do que o solucionador Z3, apesar da mesma precisão de ambos. 

Também foram descritos os resultados obtidos a cerca da verificação de todos os casos de teste presentes em \textit{esbmc--qt} utilizando ferramentas de verificação distintas (ESBMC$++$, LLBMC e DIVINE) com o objetivo de analisar a versatilidade e a eficácia de QtOM junto a outras abordagens de verificação. Cada processo de verificação e as limitações das ferramentas são descritos. Vale ressaltar que ESBMC$++$ foi capaz de identificar cerca de $89,3$\% dos erros nos casos de teste utilizados (\textit{i.e.}, $631$ dos $708$ casos de testes utilizados possuem erros), LLBMC e DIVINE apresentam, respectivamente, taxas com $81,4$\% e $89$\% (\textit{i.e.}, $576$ e $630$ dos $708$ casos de teste utilizados possuem erros). Como consequência, o método proposto não apenas se limita a uma determinada ferramenta, podendo-se adaptar para aplicações específicas em que algumas abordagens sejam mais adequedas do que outras. 

Também foi descrito os resultados obtidos atráves da verificação de duas aplicações reais \textit{Locomaps} e \textit{GeoMessage Simulator} utilizando QtOM. ESBMC$++$ junto ao modelo operacional (QtOM) foi aplicado para verificar as aplicações \textit{Locomaps} e \textit{GeoMessage Simulator} buscando verificar as seguintes propriedades: violação dos limites de um array, estouros aritméticos, divisão por zero, segurança de ponteiro e outras propriedades específicas do \textit{framework} definidas em QtOM. O processo de verificação de ambas as aplicações com a metodologia proposta levou aproximadamente $6,7$ segundos para gerar $32$ VCs para \textit{Locomaps} e $16$ segundos para gerar $6421$ VCs para \textit{GeoMessage Simulator} em um comum \textit{desktop} onde ambas aplicações possuiam o mesmo erro.

Por fim, é descrito os resultados obtidos atráves da comparação entre o comportamento real do \textit{framework} Qt e o comportamento do modelo operacional (QtOM) com o objetivo de avaliar o nível de conformidade entre ambos. Primeiramente, houve uma análise sobre todos os casos de testes presentes em \textit{esbmc--qt} com o intuito de verificar a imparcialidade e confiabilidade das aplicações. Para se obter o comportamento real do \textit{framework} Qt se utilizou um ambiente de desenvolvimento padrão denominado QtCreator. Todos os casos de testes presente em \textit{esbmc--qt} foram compilados e executados com QtCreator que por ser um ambiente de desenvolvimento padrão do \textit{framework} analisado obteve um nível de conformidade de 100\% sobre todos os casos de testes submetido. Logo em seguida, o mesmo foi realizado utilizando o compilador Clang junto com QtOM, dessa forma, se obteve o comportamento do modelo operacional (QtOM) com uma média de 97,827\% de nível de conformidade. Vale ressaltar que todo caso de teste presente em \textit{esbmc--qt} abordam todas as condições possíveis de acordo com \textit{The Qt Documentation}. De modo particular, os conjuntos de teste QHash, QSet, QMap, QMultiHash, QMultiMap, QList, QQueue, QLinkedList, QStack, QVector obtiveram níveis de conformidade de 94,667\%, 97,872\%, 91,919\%, 100,000\%, 100,000\%, 97,580\%, 100,000\%, 98,850\%, 100,000\%, 97,378\%, respectivamente. Cada conjunto de teste possui suas peculiaridades, sendo QMap o conjunto de teste que obteve o menor nível de conformidade devido a problemas em suas representações e QLinkedList sendo o conjunto que obteve o maior nível de conformidade entre os conjuntos que não obtiveram um nível igual a 100\%.

%Outros topicos
%\input{5_k-induction/algoritmo.tex}