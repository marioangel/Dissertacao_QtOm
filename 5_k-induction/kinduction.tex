%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Avaliação experimental}
\label{sec:dis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Este capítulo é dividido em cinco partes. Seção~\ref{sec:setup} descreve toda configuração experimental utilizada, os experimentos e todos os parâmetros de avaliação utilizados. Na Seção~\ref{sec:benchmark}, o desempenho e a eficácia da metodologia proposta são analisados junto a outros solucionadores SMT (Z3, Boolector e Yices 2) utilizando programas sequenciais Qt/C$++$ baseados em \textit{The Qt Documentation}~\cite{qtdocumentation}. Na Seção~\ref{sec:evaluation} é descrito os resultados obtidos a cerca da verificação de todos os casos de teste presentes na suite de teste \textit{esbmc--qt} utilizando ferramentas de verificação distintas (ESBMC$++$, LLBMC e DIVINE) com o objetivo de analisar a versatilidade e a eficácia do modelo operacional proposto junto a outras abordagens de verificação. Na Seção~\ref{sec:realqt} é descrito os resultados da verificação para as duas aplicações reais (\textit{Locomaps}~\cite{locomaps} e \textit{GeoMessage Simulator}~\cite{geomessage}) utilizando o modelo operacional proposto denominado QtOM. Por fim, é descrito na Seção~\ref{sec:conformance} os resultados da comparação entre os comportamentos do \textit{framework} analisado em relação ao modelo operacional proposto com o intuito de se avaliar o nível de conformidade entre ambos.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Configuração dos Experimentos}
\label{sec:setup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Com o intuito de avaliar a eficácia da abordagem proposta acerca da verificação de programas que utilizam o \textit{framework} Qt, foi criado um conjunto de testes automáticos denomidado \textit{esbmc--qt}. Em resumo, este conjunto de testes contém $711$ programas Qt/C$++$ ($12903$ linhas de código) baseados em \textit{The Qt Documentation}~\cite{qtdocumentation}, ou seja, todos os casos de teste utilizadas na atual avaliação.

Os casos de teste mencionados acima estão dividos em 10 principais conjuntos de teste, denominados QHash, QLinkedList, QList, QMap, QMultiHash, QMultiMap, QQueue, QSet, QStack e QVector. Vale ressaltar que todos os conjuntos de teste criados possuem casos de teste de acordo com a respectiva classe \textit{container} a ser analisada que em sua maioria possuem acesso aos módulos \textit{Qt Core} e \textit{Qt GUI} (e.g, conjunto de teste QHash possui casos de testes que foram utilizados para avaliar o processo de verificação da classe \textit{container QHash} pertencente ao \textit{framework} multiplataforma Qt). Os casos de teste foram desenvolvidos a partir da documentação~\cite{qtdocumentation} referente ao \textit{framework} analisado e também especificamente para analisar todas as característica fornecidas pelo \textit{framework}. Além disso, cada caso de teste é verificado manualmente antes de ser adicionado ao seu respectivo conjunto de teste. Desta forma, é capaz de se identificar se um determinado caso de teste possui ou não qualquer erro e está de acordo com a operação a ser realizada. Assim, com base nesta revisão, é possível garantir que $353$ dos $711$ casos de teste contêm erro (\textit{i.e.}, $49.65$\% do casos de teste analisados contêm erro) e $358$ casos de teste não possuem falhas (\textit{i.e.}, $50.35$\% dos casos de teste analisados são considerados corretos). Na realidade esse tipo de revisão é essencial para a avaliação experimental, uma vez que pode-se comparar os resultados obtidos através da verificação realizada pelas ferramentas de verificação utilizadas e avaliar adequadamente se erros reais foram encontrados. 

Todos os experimentos foram realizados em um computador Intel Core $i7$-$4790$ com $3.60$ GHz de clock e $24$ GB ($22$ GB de memória RAM e $2$ GB de mémoria virtual), utilizando-se um sistema operacional \textit{open source} de $64$ bits denominado Fedora. Além disso, também se utilizou a ferramenta de verificação ESBMC$++$~$v1.25.4$ com três tipos de solucionadores SMT instalados (Z3~$v4.0$, Boolector~$v2.0.1$ e Yices 2~$v4.1$). Os limites de tempo e memória utilizados para cada caso de teste foram definidos em 600 segundos e 22 GB, respectivamente. Por fim, uma avaliação foi realizada utilizando o CBMC~$v5.1$, LLBMC~$v2013.1$ e DIVINE~$v3.3.2$ combinados com o modelo operacinal proposto (QtOM) com o objetivo de proporcionar comparações entre ferramentas. Os períodos de tempo foram indicados usando a função \verb|clock_gettime| a partir da biblioteca \verb|time.h|~\cite{time}. Está função tem como finalidade a tomada da hora atual do sistema a partir do momento em que é chamada. Para aferir os períodos de tempo descritos, está função é chamado no inicio da aplicação para que seja tomado a sua hora inicial e no final da aplicação para que seja tomado a sua hora final. Na conclusão da aplicação é realizado uma substração entre o hora final e a hora inicial da aplicação, assim obtendo-se o período de tempo em que a aplicação se manteve ativa. O período de tempo é expresso em minutos(m) ou segundos (s) dependendo do teste realizado.   

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Comparação entre solucionadores SMT}
\label{sec:benchmark}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

É conhecido que diferentes solucionadores SMT podem afetar fortemente os resultados obtidos~\cite{TSE12}, uma vez que não existe homogeneidade em relação a abordagem de implementação e respectivas heurísticas. Primeiramente, as verificações que foram realizadas, utilizaram os três solucionadores SMT já mencionados (Z3, Boolector e Yices 2) com o objetivo de avaliar o desempenho e a eficácia da metodologia proposta. Desta forma, Yices 2 obteve os piores resultados, apresentando uma taxa de cobertura de $78$\% e um tempo de verificação de $26,27$ minutos. Dessa forma, o Yices 2 não conseguiu resolver corretamente as fórmulas SMT originadas do processo de verificação dos diversos casos de teste. Por outro lado, tanto os solucionadores Z3 quanto Boolector apresentaram uma taxa de cobertura de $89$\%, apesar do tempo de verificação obtido ao se realizar as verificações utilizando o solucionador Z3 seja inferior as realizadas com o solucionador Boolector, onde, respectivamente, são apresentados tempos de verificação de $223,6$ minutos e $26,38$ minutos. A partir dos resultados mencionados, o solucionador Boolector mostrou-se $8,5$ vezes mais rápido do que o solucionador Z3, apesar da mesma precisão de ambos, mas quatro casos de teste relataram violações a cerca do tempo limite determinado. Além disso, o Yices 2 não conseguiu analisar completamente todos os conjuntos de teste desenvolvidos, pois, não possui suporte a tuplas, logo, apresentou a menor taxa de cobertura e o menor tempo. Em resumo, de acordo com a Figura~\ref{figure:solver-comparison}, o Boolector se apresenta como o melhor solucionador para o processo de verificação proposto, pois apresenta em menor tempo a maior taxa de cobertura.

\begin{figure}[htb]
\centering
\subfloat[Taxa de cobertura]{
\includegraphics[width=0.45\textwidth]{figuras/qt-coverage.pdf}
\label{subfig-1:coverage}
}
\quad %espaco separador
\subfloat[Tempo de verificação]{
\includegraphics[width=0.45\textwidth]{figuras/qt-time.pdf}
\label{subfig-2:time}
}
\caption{Comparação entre solucionadores SMT.}
\label{figure:solver-comparison}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Verificação dos resultados para o \textit{esbmc--qt}}
\label{sec:evaluation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Todos os casos de teste presentes na suíte de teste \textit{esbmc--qt} foram verificados de forma automática por ESBMC$++$ com o objetivo de analisar a sua corretude e a eficácia do modelo operacional proposto. Além da comparação entre solucionadores SMT descrita na Seção~\ref{sec:benchmark}, uma outra análise como o objetivo de avaliar a versatilidade e a eficácia do modelo operacional proposto junto a outras abordagens de verificação também foi realizada. Como já mencionado, não existe uma ferramenta de verificação que verifique o \textit{framework} multiplataforma Qt e nem um modelo operacional semelhante ao proposto neste trabalho (QtOM) utilizando a linguagem C$++$. No entanto, devido à versatilidade do QtOM, também é possível conectá-lo ao processo de verificação de outros verificadores de modelo como LLBMC~\cite{Florian12} e DIVINE~\cite{BBH13}, cuja base deste processo é a tradução do código fonte em um representação intermediária denominada LLVM. Dessa forma, QtOM é usado como apoio em seus processos de tradução, pois o \textit{bytecode} que logo em seguida é produzido, contém informações a cerca do código fonte utilizado na verificação e do modelo operacional proposto (QtOM). Por fim, foi feito uma comparação em relação ao desempenho do LLBMC e ESBMC$++$, que são verificadores baseados em técnicas SMT, e DIVINE que emprega uma verificação de modelos através de estados explícitos. Inicialmente, houve uma tentativa de se realizar também uma comparação utilizando o verificador CBMC~\cite{CBMC14}, junto com o modelo operacional proposto (QtOM), mas devido à falhas do verificador em relação à verificação da linguagem C$++$, não foi possível realizar as verificações previstas, isto já havia sido relatado em trabalhos anteriores por Ramalho \textit{et al.}~\cite{ECBS13} e Merz \textit{et al.}~\cite{Florian12}, o que ocasionou em sua remoção durante o processo de avaliação.

As ferramentas utilizadas foram executadas seguindo três roteiros. Um para ESBMC$++$ que identifica a partir de um arquivo seus parâmetros iniciais e realiza sua execução, \footnote{esbmc *.cpp -\/-unwind $<$bound$>$  -\/-no-unwinding-assertions -I /home/libraries/ {\tt - \tt -}memlimit 14000000 {\tt - \tt -}timeout 600} outro para LLBMC que usando CLang\footnote{/usr/bin/clang++ -c -g -emit-llvm *.cpp -fno-exceptions}~\cite{CLANG} compila o código fonte desejado criando seu \textit{bytecode} e logo em seguida, também a partir de um arquivo identifica seus parâmetros iniciais e realiza a sua execução\footnote{llbmc *.cpp --ignore-missing-function-bodies --max-loop-iterations=$<$bound$>$ --no-max-loop-iterations-checks} e outro para DIVINE que também pré-compila os códigos fontes em C$++$ criando seus respectivos \textit{bytecode}\footnote{divine compile --llvm -o main.bc *.cpp} para que em seguida realize sua verificação sobre eles. \footnote{divine verify main.bc --max-time=600 --max-memory=14000 -d} O desdobramento de laços é definido para cada ferramenta, isto é, o valor de $<$\textit{bound}$>$ varia entre os casos de teste. Por enquanto, o LLBMC não suporta tratamento de exceção e os \textit{bytecodes} que foram criados estavam com a opção \textit{-fno-exceptions} ativa em seu compilador. Vale ressaltar, que se está opção estiver ativa, o LLBMC sempre abortará durante seu processo de verificação.

A Tabela~\ref{table:results-of-ESBMC} mostra os resultados experimentais para as junções entre QtOM e LLBMC, DIVINE e ESBMC$++$ usando Boolector como seu principal solucinador SMT. \textit{TC} representa o número de programas Qt/C$++$, \textit{L} representa a quantidade total de linhas de código, \textit{Time} representa o tempo total da verificação, \textit{P} representa o número de casos de teste sem defeitos (\textit{i.e.}, resultados positivos corretos), \textit{N} representa o número de casos de teste com defeitos (\textit{i.e.}, resultados negativos corretos), \textit{FP} representa o número falsos positivos obtidos (\textit{i.e.}, a ferramenta relata programas que estão corretos como incorretos), \textit{FN} representa o número de falsos negativos obtidos (\textit{i.e.}, a ferramenta relata programas incorretos como corretos) e \textit{Fail} representa o número de erros internos obtidos durante a verificação (e.g., erros de análise). Vale ressaltar que o ESBMC$++$ utilizando Boolector não apresenta estouro de memória e tempo em qualquer caso de teste utilizado.

\begin{table}[!htb]
%\begin{adjustwidth}{-0.5cm}{}
\renewcommand\arraystretch{0.95}
\setlength{\tabcolsep}{0.7pt}
\begin{center} {\small
\begin{tabular}{|l|l|r||r|r|r|r|r|r||r|r|r|r|r|r||r|r|r|r|r|r|r|}
\hline
& & & \multicolumn{6}{c||}{ESBMC$++$ v1.25.4}  & \multicolumn{6}{c||}{LLBMC v2013.1}  & \multicolumn{6}{c|}{DIVINE v3.3.2} \\\cline{4-21}
 \textbf{Suíte de teste}    &\textbf{TC}	& \textbf{L}	& \textbf{Time} 	& \textbf{P}  	& \textbf{N}  	& \textbf{FP} 	& \textbf{FN}  & \textbf{Fail}  	& \textbf{Time} 	& \textbf{P}  	& \textbf{N}  	& \textbf{FP} 	& \textbf{FN}  & \textbf{Fail} & \textbf{Time} 	& \textbf{P}  	& \textbf{N}  	& \textbf{FP} 	& \textbf{FN}  & \textbf{Fail} \\\hline
QHash 	   	& 74  	& 1170  	& 117.2   		& 33  	& 33  	& 4  		& 4	  	& 0   			& 37.13   		& 31  	& 37  	& 0  		& 6	  	& 0   		& 1432.5   	& 32  	& 33  	& 0  		& 1	  	& 8 \\ % OK
\hline
QLinkedList 	& 87 		& 1700  	& 77.0  		& 40   	& 39 		& 2   		& 2    	& 4  			& 23.3   		& 18  	& 41 		& 2	  	& 26	  	& 0  	         & 1907.6	   	& 30  	& 42  	& 1  		& 14	  	& 0    \\ % OK
\hline	
QList 		& 124  	& 2317  	& 102.1  		& 53 		& 55 		& 7   		& 9  	 	& 0  			& 19.4   		& 28  	& 56  	& 0	  	& 28	  	& 12  	& 2599.7   	& 52  	& 56  	& 0 		& 4	  	& 12    \\ % OK
\hline
QMap 		& 99  	& 1989  	& 277.2  		& 42 		& 39 		& 10   	& 8   		& 0  			& 406.4   		& 41  	& 46  	& 2  		& 8	  	& 2   		& 2109.9   	& 40  	& 44  	& 0  		& 5	  	& 10   \\ % OK
\hline 
QMultiHash 	& 24  	& 363   	& 186.4   		& 12    	& 12   	& 0   		& 0    	& 0  			& 30.8   		& 12  	& 12  	& 0  		& 0	  	& 0   		& 466.3     	& 13  	& 12  	& 0  		& 0	  	& 0   \\ % OK
\hline
QMultiMap 	& 26   	& 504   	& 136.9		& 13  	& 13   	& 0   		& 0    	& 0  			& 32.0   		& 13  	& 13  	& 0  		& 0	  	& 0   		& 549.9     	& 14  	& 13  	& 0  		& 0	  	& 0    \\ % OK
\hline
QQueue  		& 16   	& 299  	& 191  		& 8   		& 8  		& 0   		& 0    	& 0  			& 3.9   		& 8    	& 8    	& 0  		& 0	  	& 0   		& 339.7     	& 8  	        & 8    	& 0  		& 0	  	& 0    \\ % OK
\hline
QSet 		& 94   	& 1702  	& 500.5  		& 43   	& 43  	& 4  		& 4    	& 0  			& 132.6   		& 40  	& 44  	& 1  		& 5	  	& 4   		& 1897.2   	& 40  	& 41  	& 0  		& 0	  	& 13   \\ % OK
\hline
QStack 		& 12  	& 280  	& 14.5 		& 5 		& 5 		& 0  		& 0   		& 2  			& 2.2   		& 6	   	& 5    	& 1  		& 0	  	& 0   		& 262.1     	&6  	        & 6  	        	& 0  		& 0	  	& 0     \\ % OK
\hline
QVector 		& 152  	& 2582  	&157.3 		& 67  	&68  		& 7  		&8  		& 2  			& 1825.7  		& 44  	& 73  	& 0 		& 29	  	& 6    	& 3057.5   	& 68  	& 72  	& 0  		& 6	  	& 6  \\ % OK
\hline\hline
\textbf{Total} 		& 708 	& 12903 	& 1760		& 316 	& 315	& 34 		& 35   	& 8  			& 2513.5  		& 241  	& 335  	& 6 		& 102	& 24  	& 14722.4   	& 303  	& 327  	& 1  		& 30	  	& 49  \\ % OK
\hline
\end{tabular} }
\end{center}
\caption{Resultados obtidos da comparação entre ESBMC$++$ v1.25.4 (usando Boolector como solucionador SMT), LLBMC v2013.1 e DIVINE v3.3.2.}
\label{table:results-of-ESBMC}
%\end{adjustwidth}
\end{table}

De acordo com a Tabela~\ref{table:results-of-ESBMC}, apenas $1,1$\% dos casos de teste com o ESBMC$++$ alegaram falhas durante sua verificação, isto ocorre quando a ferramenta não é capaz de realizar a verificação de um determinado programa devido à erros internos encontrados. DIVINE e LLBMC apresentam taxas de falha de $6,9$\% e $3,4$\%, respectivamente, por conta de tais ferramentas não conseguirem criar os \textit{bytecodes} dos programas utilizados ou durante a verificação realizada foi relatado que houve um estouro de memória ou de tempo. Em relação aos resultados $FP$, DIVINE obteve o melhor desempenho seguido por LLBMC e ESBMC$++$. Contudo, ESBMC$++$ obteve a taxa mais baixa em relação aos resultados de falsos negativos ($FN$) seguido por DIVINE e por fim LLBMC, isso ocorre devido à forma que os \textit{iterators} estão implementados no modelo operacional proposto (QtOM), por meio de ponteiros e vetores com o objetivo de simular seus comportamentos de forma real e de acordo com o visto no Capítulo~\ref{chapter:container-model}. No entanto, a estrutura criada não cobre todos os comportamentos descritos na documentação do \textit{framework}. Em particular, quando uma remoção de um elemento é realizada em um \textit{container} em que existe mais de um \textit{iterator} apontando para ele, todos os \textit{iterators} que apontam para o elemento que foi removido serão perdidos. Desta forma, este comportamento afetará as pós-condições de um programa que influenciam diretamente nos resultados obtidos em relação a \textit{FP} e \textit{FN}. Vale ressaltar que vetores e ponteiros têm sido extensivamente utilizados, de modo a obter estruturas simples, isto é, sem classes e \textit{structs} em sua representação o que diminui a complexidade do processo de verificação (ver Seção~\ref{sec:postconditions}). Por fim, os resultados da combinação entre ESBMC$++$ e QtOM em um verificador robusto, ainda possui algumas lacunas a serem preenchidas a respeito do suporte a linguagem C$++$ como descrito por Ramalho \textit{et al.}~\cite{ECBS13}.

Vale mencionar que o nível de complexidade ao se verificar o código fonte de um programa aumenta de acordo com a quantidade de estruturas (dados, repetição, seleção, etc.) que possuir. No entanto, de acordo como mostrado na Figura~\ref{figure:time}, os conjuntos de teste QMap e QSet apresentam os maiores tempos durante o processo de verificação ao se utilizar o ESBMC$++$, apesar de QVector ser o mais extenso conjunto de casos de teste existente. Isso acontece por ser analisado a quantidade de laços presente no programa e não somente o número de linhas de código que ele possui, o que afeta diretamente os tempos de verificação. Na realidade, as estruturas internas associadas ao modelo operacional das classes \textit{QMap} e \textit{QSet} contêm mais laços do que as demais, desta forma, obtém-se tempos de verificação mais longos. Como também visto na Figura~\ref{figure:time}, o LLBMC apresenta um maior tempo de verificação ao se utilizar o conjunto de teste QVector, na qual, isto ocorre devido a $2$ casos de teste em que houve estouro do tempo estimado para que seja realizada a verificação. Além disso, o DIVINE é a ferramenta que apresenta o menor desempenho entre as citadas, pois, seu processo de criação do \textit{bytecode} é mais custoso do que a realização da verificação sobre o mesmo. Dessa forma, os conjuntos de teste com mais programas a serem analisados obtiveram os maiores tempos que no caso são QVector, QList, QMap, QLinkedList e QSet.

\begin{figure}[htb]
  \centering
  \includegraphics[width=5.5in]{figuras/Time.pdf}
  \caption{Comparação entre os tempos de verificação em relação a ESBMC$++$, LLBMC e DIVINE.}
  \label{figure:time}
\end{figure}

A Figura~\ref{figure:coverage} mostra que todos os verificadores obtiveram uma taxa de corbetura acima de 80\% para os \textit{containers} do tipo associativo. Contudo, o LLBMC não se manteve com a mesma taxa ao analisar os \textit{containers} do tipo sequencial. Vale ressaltar que todos os casos de teste a partir dos conjuntos de teste QMultiMap e QMultiHash foram verificados corretamente por todos os verificadores utilizados. Os conjuntos de teste QHash, QMap e QSet, por sua vez, apresentaram uma taxa média de $6,7$\% para resultados falsos positivos e falsos negativos, ou seja, de $3$ a $18$ casos de teste dos $267$ casos de teste são considerados falsos positivos ou falsos negativos, isso ocorre devido às limitações na representação interna dos \textit{iterators}. Além disso, o LLBMC e DIVINE, respectivamente, não conseguiram verificar cerca de $4,5$\% e $13,9$\% dos casos de teste dos \textit{containers} associativos, ou seja, $12$ e $13$ dos $267$ casos de teste não conseguiram ser verificados devido às falhas no processo de criação do \textit{bytecode}. Em relação aos \textit{containers} do tipo sequencial, LLBMC apresentou baixas taxas de cobertura para os conjuntos de teste QVector, QLinkedList e QList, taxas a cerca de $67,7$\% a $77$\%, ou seja, $84$/$117$ dos $124$/$152$ casos de teste, respectivamente. Além disso, cerca de $22,9$\% dos casos de teste ($83$ dos $363$ analisados) apresentaram resultados falsos negativos devido também à problemas com a representação interna dos \textit{iterators}. Vale ressaltar, que cerca de $5$\% dos casos de teste ($18$ dos $363$ analisados) não haviam sido verificados por LLBMC, uma vez que não foi capaz de criar os \textit{bytecodes} desejados. O ESBMC$++$ e DIVINE, por sua vez, apresentaram uma taxa de erro de no máximo de $6,6$\%, ou seja, $24$ dos $363$ casos de teste para os conjuntos de teste QVector, QLinkedList e QList apresentam erros de análise em suas pós-condições. Além disso, todos os casos de teste dos conjuntos de teste QQueue e QStack foram verificados corretamente, com exceção de dois casos presentes em QStack, pois, ao se utilizar o Boolector com a ferramenta ESBMC$++$, não foi possível obter uma solução para as fórmulas SMT criadas para os casos analisados. 

\begin{figure}[htb]
  \centering
  \includegraphics[width=5.5in]{figuras/Coverage.pdf}
  \caption{Comparação entre a taxa de cobertura em relação a ESBMC++, LLBMC e DIVINE.}
  \label{figure:coverage}
\end{figure}

Os conjuntos de teste QList, QMap, QVector e QSet possuem mais resultados falsos positivos e negativos em seus testes ao se utilizar o ESBMC$++$ do que as outras ferramentas. A taxa de cobertura a cerca dos casos de teste verificados corretamente se encontra em torno de $80$\% a $90$\%, respectivamente, o que demonstra a eficácia em relação a verificação realizada uma vez que cada caso de teste verifica características diferentes dos \textit{containers} sequenciais e associativos.

Vale ressaltar que o ESBMC$++$ foi capaz de identificar cerca de $89,3$\% dos erros nos casos de teste utilizados (\textit{i.e.}, $631$ dos $708$ casos de testes utilizados possuem erros), o que demonstra também a eficácia da metodologia proposta. Similarmente, LLBMC e DIVINE apresentam, respectivamente, taxas com $81,4$\% e $89$\% (\textit{i.e.}, $576$ e $630$ dos $708$ casos de teste utilizados possuem erros), o que também demonstra uma boa adequação do modelo operacional proposto (QtOM) combinado com outras ferramentas de verificação. Como consequência, a metodologia proposta não apenas se limita a uma determinada ferramenta, podendo-se adaptar para aplicações específicas em que algumas abordagens sejam mais adequedas do que outras. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Verificação dos resultados para aplicações reais}
\label{sec:realqt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Dado que o conjunto de casos de teste proposto possui como objetivo verificar propriedades específicas dos módulos pertencentes ao \textit{framework} multiplataforma Qt, também é necessário incluir resultados de verificações que envolvam aplicações reais. Os parágrafos seguintes descrevem as respectivas aplicações e seus resultados associados.

A aplicação chamada \textit{Locomaps}~\cite{locomaps} é um exemplo de programa que utiliza o \textit{framework} multiplataforma Qt e exibe imagens de satélite, terrenos, mapas de ruas, serviço de planejamento de mapas em mosaicos e possui um integração com GPS \textit{Qt Geo}. Utilizando o mesmo código fonte esta aplicação pode ser compilada e executada nos principais sistemas operacionais existentes (Mac OS X, Linux e Windows). Está aplicação possui duas classes com $115$ linhas de código no total, utilizando Qt/C$++$ e usando cinco APIs diferentes do framework Qt (\textit{QApplication}, \textit{QCoreApplication}, \textit{QDesktopWidget}, \textit{QtDeclarative} e \textit{QMainWindow}). Vale mencionar que o código escrito em Qt/C$++$ desta aplicação, as APIs e as bibliotecas utilizadas são considerados no processo de verificação, assim como, as propriedades relacionadas a eles. 

ArcGIS~\cite{ArcGIS} para as forças armadas é uma plataforma geográfica que é utilizado para criar, organizar e compartilhar materiais geográficos com usuários que utilizam mapas inteligentes \textit{online}. A partir disso, \textit{GeoMessage Simulator}~\cite{geomessage} possui como entrada de dados arquivos XML e cria em diferentes frequências datagramas utilizando o protocolo de datagramas por usuário (\textit{em inglês}, User Datagram Protocol - UDP) para aplicações ArcGIS e componentes do sistema. \textit{GeoMessage Simulator} também é uma aplicação multi-plataforma que contém $1209$ linhas de códigos em Qt/C$++$ que utiliza $20$ diferentes APIs do \textit{framework} multiplataforma Qt englobando várias características, tais como o sistema de eventos de Qt, \textit{strings}, manipulação de arquivos e \textit{widgets}. Vale ressaltar que \textit{GeoMessage Simulator} usa duas classes, \textit{QMutex} e \textit{QMutexLocker}, relacionadas ao módulo \textit{Qt Threading} que possui classes para programas concorrentes. Tais classes foram utilizadas na aplicação para travar ou destravar mutexes e, o mais importante, ESBMC$++$ é capaz de verificar adequadamente esses tipos de estruturas. No entanto, o modelo operacional proposto (QtOM) ainda não fornece um suporte completo para o módulo \textit{Qt Threading}.

O ESBMC$++$ junto ao modelo operacional proposto (QtOM) foi aplicado para verificar as aplicações \textit{Locomaps} e \textit{GeoMessage Simulator} buscando verificar as seguintes propriedades: violação dos limites de um array, estouros aritméticos, divisão por zero, segurança de ponteiro e outras propriedades específicas do \textit{framework} definidas em QtOM de acordo com o Capítulo~\ref{chapter:smt-bmc}. Além disso, o ESBMC$++$ foi capaz de identificar completamente o código-fonte de cada aplicação, utilizando cinco diferentes módulos de QtOM para \textit{Locomaps} e vinte módulos para \textit{GeoMessage Simulator}, ou seja, cada módulo de QtOM usado correspondia a uma API utilizada pela aplicação que seria verificada. O processo de verificação de ambas as aplicações foi totalmente automático e a metodologia proposta levou aproximadamente $6,7$ segundos para gerar $32$ VCs para \textit{Locomaps} e $16$ segundos para gerar $6421$ VCs para \textit{GeoMessage Simulator} em um comum \textit{desktop}. Além disso, o ESBMC$++$ não relata caso haja qualquer falso negativo, mas foi capaz de encontrar bugs semelhantes em ambas as aplicações, as quais foram confirmadas pelos desenvolvedores e são explicadas abaixo.

\begin{figure}[h]
\centering
\begin{minipage}{0.60\textwidth}
\begin{lstlisting}
int main(int argc, char *argv[]) {
  QApplication app(argc, argv);
  return app.exec();
}
\end{lstlisting}
\end{minipage}
\caption{Fragmento de código do arquivo principal da aplicação \textit{Locomaps}.}
\label{fig:Fig6}
\end{figure}

A Figura~\ref{fig:Fig6} mostra um fragmento de código retirado do principal arquivo da aplicação \textit{Locomaps} que utiliza a classe \textit{QApplication} que está presente no módulo \textit{QtWidgets}. Nesse caso em particular, se o parâmetro $argv$ não for corretamente inicializado, logo o construtor ao ser chamado pelo objeto $app$ não é executado de forma correta acarretando em falhas na aplicação (veja a linha $2$, na Figura~\ref{fig:Fig6}). A fim de verificar esta propriedade, o ESBMC$++$ analisa 2 assertivas em relação aos parâmetros de entrada da aplicação (veja as linhas $4$ e $5$, na Figura~\ref{fig:Fig7}), avaliando-as como pré-condições. Um erro semelhante também foi encontrado na aplicação \textit{GeoMessage Simulator} e uma maneira possível para corrigir tal erro é sempre verificar, com instruções condicionais, se $argv$ e $argc$ são argumentos válidos antes de utiliza-las em uma operação.\\\\\\

\begin{figure}[h]
\centering
\begin{minipage}{0.60\textwidth}
\begin{lstlisting}
class QApplication {
  ...
  QApplication( int & argc, char ** argv ){
  __ESBMC_assert(argc > 0, ``Invalid parameter'');
  __ESBMC_assert(argv != NULL, ``Invalid pointer'');
  this->str = argv;
  this->_size = strlen(*argv);
  ...
 }
 ...
};
\end{lstlisting}
\end{minipage}
\caption{Modelo operacional para o construstor de $QApplication$().}
\label{fig:Fig7}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Verificação da conformidade de QtOM}
\label{sec:conformance}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Todos os processos, funções, APIs, ferramentas e especificações necessárias para o desenvolvimento de aplicações que utilizam o \textit{framework} multiplataforma Qt são descritas por \textit{The Qt Developers} em~\cite{qtdevelopers}. Na verificação de modelos, as aplicações analisadas se utilizam de funções disponibilizadas pelo ambiente de verificação criado com o objetivo de garantir a exatidão da verificação, ou seja, se obter uma análise de forma correta. Para que isso ocorra, o comportamento do sistema desenvolvido (modelo operacional) deve ser o mesmo do sistema real (\textit{framework}) analisado. 

Inicialmente, foi realizado uma análise sobre todos os casos de testes utilizados em \textit{esbmc--qt} com intuito de verificar a imparcialidade e a confiabilidade das aplicações utilizadas. Todos os casos de teste analisados foram desenvolvidos utilizando a linguaguem C++ junto com as funções disponibilizadas pelo \textit{framework} Qt, onde cada implementação usa as estruturas de dados e funções presente em Qt \textit{containers} em todas as condições possíveis de acordo com \textit{The Qt Documentation}~\cite{qtdocumentation}. Cada caso de teste proporciona uma falha e um sucesso de acordo com a estrutura ou função empregada. Logo em seguida, todos os casos de testes presentes em \textit{esbmc--qt} foram compilados e executados utilizando o ambiente de desenvolvimento do Qt denominado QtCreator. QtCreator é um ambiente de desenvolvimento integrado (IDE) multiplataforma utilizado por desenvolvedores para criar diversas aplicações que utilizam o \textit{framework} Qt para desktops, sistemas embarcados e plataformas de dispositivos móveis. É um ambiente de desenvolvimento disponível para Linux, OS X e Windows~\cite{qtcreator}. Dessa forma, se obteve um comportamento base de Qt \textit{containers} que seria comparado ao comportamento do modelo operacional proposto (QtOM) com o objetivo de verificar o nível de semelhança entre ambos, visto que não há outra ferramenta ou modelo operacional desenvolvido até o momento. Por fim, os mesmo casos de teste compilados e executados por QtCreator foram compilados e executados por Clang com o modelo operacional proposto (QtOM) intregado a ele com o intuito de se determinar o seu comportamento.

A Figura~\ref{fig:conformance} mostra o resultado da comparação descrita anteriormente, assim como, em testes anteriores os conjuntos de testes estão divididos em \textit{containers} associativos compostos por QHash, QSet, QMap, QMultiHash e QMultiMap e \textit{containers} sequenciais compostos por QList, QQueue, QLinkedList, QStack e QVector. Vale ressaltar que por QtCreator ser o ambiente de desenvolvimento padrão do \textit{framework} Qt, obteve um nível de conformidade de 100\% em todos os conjuntos de testes que compõe \textit{esbmc--qt}, em todas as condições possíveis de acordo com \textit{The Qt Documentation}~\cite{qtdocumentation}. Entretanto, ao se analisar o comportamento do compilador Clang junto com o modelo operacional proposto (QtOM), se obtem um nível de conformidade com média de 97,827\% em todos os conjuntos de testes que compõe \textit{esbmc--qt} em todas as condições possíveis de acordo com \textit{The Qt Documentation}~\cite{qtdocumentation}. 

Ao se analisar de modo particular, os conjuntos de testes QMultiHash, QMultiMap, QQueue, QStack obtiveram um nível de 100\% de semalhança comparado aos resultados obtidos por QtCreator. O conjunto de teste QMap obteve o menor nível de semelhança de 91,919\% em relação a QtCreator, isso ocorreu devido algumas representações presente no modelo operacional possuirem erros no uso de seus  iterators o que impossibilitava o acesso de determinados dados nas estruturas representadas e nas representações que utilizam funções estáticas, na qual, havia a perda do dado utilizado na estrutura representada, QMap é considerado o conjunto de teste com o maior número de falsos positivos e negativos entres os conjuntos de teste existentes correspondendo a cerca de 8,080\% dos seus casos de teste. Os conjuntos de testes QHash, QLinkedList e QList, respectivamente, obtiveram níveis de semelhança de 94,667\%, 98,850\%, 97,580\%, isso ocorreu devido a problemas com a representação de iterators usadas no modelo operacional, assim como, em QMap ao se utilizar mais de um iterator no caso de teste, a referência sobre os demais iterators utilizados é perdida no momento em que se usa um iterator para acessar/modificar dados presente no \textit{container} analisado. O conjunto de teste QLinkedList é o conjunto de teste que obteve o maior nível de semelhança entre os conjuntos de teste que não obtiveram um nível de conformidade de 100\%. O conjunto de teste QSet obteve um nível de semelhança de 97,872\% em relação a QtCreator, isso ocorreu devido algumas representações possuirem problemas em suas funções estáticas havendo perda de dados nas estruturas representadas. Por fim, o conjunto de caso QVector considerado o maior conjunto em número de casos de teste obteve um nível de semalhança de 97,378\%, pois não foi possível realizar a representação de funções onde em suas definições tinham como objetivo realizar algum tipo de manipulação da memória como "Ajuste fino" "Melhoria no gerenciamento da memória" (e.g. a função tem como aplicabilidade armazenar ou liberar uma quantidade da memória utilizada pelo o programa para o melhor uso do \textit{container}) entre outras definições. Vale ressaltar que não é possível criar esses tipos de representação, pois não se sabe como o \textit{framework} analisado trata essas funções internamente o que impossibilita criar uma representação na linguagem base utilizada. O conjunto QVector também teve problemas relacionados a utilização de mais um iterator, assim como, os conjuntos QMap, QHash, QLinkedList e QList. Como proposta para os erros encontrados a nível de conformidade, o uso de uma estrutura que fizesse o armazenamento dos dados mesmo que de forma temporária poderia auxiliar as aplicações tanto estáticas como as que se utilizam mais de um iterator no manuseio interno dos dados vindos da aplicação, assim evitando a perda de referência em ambos os problemas encontrados.

\begin{figure}[htb]
  \centering
  \includegraphics[width=5.5in]{figuras/conformance.png}
  \caption{Comparação entre o comportamento de QtCreator e Clang+QtOM parar medir a conformidade de QtOM.}
  \label{fig:conformance}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Resumo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

De acordo com o embasamento teórico realizado pelos capítulos anteriores em relação as técnicas SMT utilizadas, o processo de verificação de ESBMC++ e o modelo operacional QtOM desenvolvido. Neste capítulo, inicialmente foi descrito como foi construída a configuração dos experimentos realizados, com o intuito de avaliar a eficácia da metodologia proposta a cerca da verificação de programas que utilizam o \textit{framework} multiplaforma Qt, a partir de uma suíte de testes denomidado \textit{esbmc--qt} que contém todos os casos de teste utilizadas na atual avaliação. O \textit{esbmc--qt} contém $711$ programas Qt/C$++$ que de acordo com os experimentos realizados é possível garantir que $353$ dos $711$ casos de teste contêm erro (\textit{i.e.}, $49.65$\% do casos de teste analisados contêm erro) e $358$ casos de teste não possuem falhas (\textit{i.e.}, $50.35$\% dos casos de teste analisados são considerados corretos). 

Em seguida, foi descrito como foi realizado e avaliado a comparação entre os solucionadores SMT utilizados (Z3, Boolector e Yices 2) junto com o ESBMC$++$ utilizando programas Qt/C$++$ sequenciais. Isso foi realizado, pois, solucionadores SMT podem afetar fortemente os resultados obtidos, uma vez que não existe homogeneidade em relação a abordagem de implementação e respectivas heurísticas. Sendo assim, Yices 2 obteve os piores resultados, apresentando uma taxa de cobertura de $78$\% e um tempo de verificação de $26,27$ minutos mas tanto Z3 quanto Boolector apresentaram uma taxa de cobertura de $89$\% com tempos de verificação de $223,6$ minutos e $26,38$ minutos, respectivamente. Por fim, Boolector mostrou-se $8,5$ vezes mais rápido do que o solucionador Z3, apesar da mesma precisão de ambos. 

Também foram descritos os resultados obtidos a cerca da verificação de todos os casos de teste presentes na suíte de teste \textit{esbmc--qt} utilizando ferramentas de verificação distintas (ESBMC$++$, LLBMC e DIVINE) com o objetivo de analisar a versatilidade e a eficácia do modelo operacional proposto junto a outras abordagens de verificação. Cada processo de verificação e as limitações das ferramentas são descritos. Vale ressaltar que o ESBMC$++$ foi capaz de identificar cerca de $89,3$\% dos erros nos casos de teste utilizados (\textit{i.e.}, $631$ dos $708$ casos de testes utilizados possuem erros), LLBMC e DIVINE apresentam, respectivamente, taxas com $81,4$\% e $89$\% (\textit{i.e.}, $576$ e $630$ dos $708$ casos de teste utilizados possuem erros). Como consequência, a metodologia proposta não apenas se limita a uma determinada ferramenta, podendo-se adaptar para aplicações específicas em que algumas abordagens sejam mais adequedas do que outras. 

Também foi descrito os resultados obtidos atráves da verificação de duas aplicações reais \textit{Locomaps} e \textit{GeoMessage Simulator} utilizando o QtOM. O ESBMC$++$ junto ao modelo operacional proposto (QtOM) foi aplicado para verificar as aplicações \textit{Locomaps} e \textit{GeoMessage Simulator} buscando verificar as seguintes propriedades: violação dos limites de um array, estouros aritméticos, divisão por zero, segurança de ponteiro e outras propriedades específicas do \textit{framework} definidas em QtOM. O processo de verificação de ambas as aplicações com a metodologia proposta levou aproximadamente $6,7$ segundos para gerar $32$ VCs para \textit{Locomaps} e $16$ segundos para gerar $6421$ VCs para \textit{GeoMessage Simulator} em um comum \textit{desktop} onde ambas aplicações possuiam o mesmo erro.

Por fim, é descrito os resultados obtidos atráves da comparação entre o comportamento real do \textit{framework} multiplataforma Qt e o modelo operacional desenvolvido (QtOM) com o objetivo de avaliar o nível de conformidade entre ambos. Primeiramente, houve uma análise sobre todos os casos de testes de \textit{esbmc--qt} com o intuito de verificar a imparcialidade e confiabilidade das aplicações. Para se obter o comportamento real do \textit{framework} Qt se utilizou um ambiente de desenvolvimento padrão denominado QtCreator. Todos os casos de testes presente em \textit{esbmc--qt} foram compilados e executados com QtCreator que por ser um ambiente de desenvolvimento padrão do \textit{framework} analisado obteve um nível de conformidade de 100\% sobre todos os casos de testes submetido. Logo em seguida, os mesmos casos de testes utilizados em QtCreator foram compilados e executados utilizando Clang+QtOM, dessa forma, se obteve o comportamento do modelo operacional desenvolvido com uma média de 97,827\% de nível de conformidade. Vale ressaltar que todo caso de teste presente em \textit{esbmc--qt} abordam todas as condições possíveis de acordo com \textit{The Qt Documentation}. De modo particular, os conjuntos de teste QHash, QSet, QMap, QMultiHash, QMultiMap, QList, QQueue, QLinkedList, QStack, QVector obtiveram níveis de conformidade de 94,667\%, 97,872\%, 91,919\%, 100,000\%, 100,000\%, 97,580\%, 100,000\%, 98,850\%, 100,000\%, 97,378\%, respectivamente. Cada conjunto de teste possui suas peculiaridades, sendo QMap o conjunto de teste que obteve o menor nível de conformidade devido a problemas em suas representações e QLinkedList sendo o conjunto que obteve o maior nível de conformidade entre os conjuntos que não obtiveram um nível igual a 100\%.

%Outros topicos
%\input{5_k-induction/algoritmo.tex}