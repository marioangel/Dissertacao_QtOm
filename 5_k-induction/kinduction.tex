%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Avaliação experimental}
\label{sec:dis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Este capítulo é dividido em quatro partes. Seção~\ref{sec:setup} descreve toda configuração experimental utilizada, os experimentos e todos os parâmetros de avaliação utilizados para a realização das avaliações. Na seção~\ref{sec:benchmark}, a corretude e também o desempenho da metodologia proposta são verificados, utilizando programas Qt/C$++$ \textit{single-thread} baseados na documentação do \textit{framework} multiplataforma Qt~\cite{Qt15}. Na seção~\ref{sec:evaluation} é descrito os resultados obtidos a cerca da verificação de todos os casos de teste presentes na suite de teste \textit{esbmc--qt} utilizando ferramentas de verificação distintas (ESBMC$++$, LLBMC e DIVINE) com o objetivo de analisar a corretude e a eficácia do modelo operacional proposto junto as ferramentas mencionadas. Por fim, é descrito na seção~\ref{sec:realqt} os resultados da verificação para as duas aplicações reais (\textit{Locomaps}~\cite{locomaps} e \textit{GeoMessage Simulator}~\cite{geomessage}) utilizando o modelo operacional proposto denominado QtOM.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Configuração Experimental}
\label{sec:setup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Com o intuito de avaliar a eficácia da abordagem proposta a cerca da verificação de programas que utilizam o \textit{framework} Qt, um conjunto de testes automáticos denomidado \textit{esbmc--qt} foi criado. Em resumo, neste conjunto de testes contém $711$ programas Qt/C$++$ ($12903$ linhas de código), ou seja, todos os casos de teste utilizadas na atual avaliação.

Os casos de teste mencionados acima estão dividos em 10 principais conjuntos de teste, denominados QHash, QLinkedList, QList, QMap, QMultiHash, QMultiMap, QQueue, QSet, QStack e QVector. Vale ressaltar que todos os conjuntos de teste criados possuem casos de teste de acordo com a respectiva classe container a ser analisada (\textit{e.g}, conjunto de teste QHash possui casos de testes que foram utilizados para avaliar o processo de verificação da classe \textit{container QHash} pertencente ao \textit{framework} multiplataforma Qt) que em sua maioria possuem acesso aos módulos \textit{Qt Core} e \textit{Qt GUI}. Alguns casos de teste foram desenvolvidos a partir da documentação referente ao \textit{framework} analisado e os restantes foram desenvolvidos especificamente para analisar todas as característica fornecidas pelo \textit{framework}. Além disso, cada caso de teste é verificado manualmente antes de ser adicionado ao seu respectivo conjunto de teste. Desta forma, é capaz de se identificar se um determinado caso de teste possui ou não qualquer erro e está de acordo com a operação a ser realizada. Assim, com base nesta revisão, é possível garantir que $353$ dos $711$ casos de teste contêm erro (\textit{i.e.}, $49.65$\% do casos de teste analisados contêm erro) e $358$ casos de teste não possuem falhas (\textit{i.e.}, $50.35$\% dos casos de teste analisados são considerados corretos). Na realidade esse tipo de revisão é essencial para a nossa avaliação experimental, uma vez que pode-se comparar os resultados obtidos através da verificação realizada pelas ferramentas de verificação utilizadas e avaliar adequadamente se erros reais foram encontrados. 

Todos os experimentos foram realizados em um computador Intel Core $i7$-$4790$ com $3.60$ GHz de clock e $24$ GB ($22$ GB de memória RAM e $2$ GB de mémoria virtual), utilizando-se um sistema operacional \textit{open source} de $64$ bits denominado Fedora. Além disso, também se utilizou a ferramenta de verificação ESBMC$++$~$v1.25.4$ com três tipos de solucionadores SMT instalados (Z3~$v4.0$, Boolector~$v2.0.1$ e Yices 2~$v4.1$). Os limites de tempo e memória utilizados para cada caso de teste foram respectivamente definidos em 600 segundos e 22 GB. Por fim, uma avaliação foi realizada utilizando CBMC~$v5.1$, LLBMC~$v2013.1$ e DIVINE~$v3.3.2$ combinados com o modelo operacinal proposto (QtOM) com o objetivo de proporcionar comparações entre ferramentas. Os períodos de tempo foram indicados usando a função \verb|clock_gettime| a partir da biblioteca \verb|time.h|~\cite{time}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Comparação entre solucionadores SMT}
\label{sec:benchmark}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

É conhecido que diferentes solucionadores SMT podem afetar fortemente os resultados obtidos, uma vez que não existe homogeneidade em relação a abordagem de implementação e as lógicas suportadas. Primeiramente, foram realizadas verificações usando os três solucionadores SMT mencionados (Z3, Boolector e Yices 2). Sendo assim, Yices 2 obteve os piores resultados, apresentando uma taxa de cobertura de $78$\% e um tempo de verificação de $26,27$ minutos. Dessa forma, não conseguiu resolver corretamente as fórmulas SMT originadas do processo de verificação dos diversos casos de teste. Por outro lado, tanto os solucionadores Z3 quanto Boolector apresentaram uma taxa de cobertura de $89$\%, apesar do tempo de verificação obtido ao se realizar as verificações utilizando o solucionador Z3 seja inferior as realizadas com o solucionador Boolector, onde, respectivamente, são apresentados tempos de verificação de $223,6$ minutos e $26,38$ minutos. A partir dos resultados mencionados, o solucionador Boolector mostrou-se $8,5$ vezes mais rápido que o solucionador Z3, apesar da mesma precisão de ambos, mas quatro casos de teste relataram violações a cerca do tempo limite determinado. Além disso, Yices 2 não conseguiu analisar completamente todos os conjuntos de teste desenvolvidos, pois, não possui suporte a tuplas, logo, apresentou a menor taxa de cobertura e o menor tempo. Em resumo, de acordo com a figura ~\ref{figure:solver-comparison} Boolector se apresenta como o melhor solucionador para o processo de verificação proposto, pois, apresenta em menor tempo a maior taxa de cobertura.

\begin{figure}[htb]
\centering
\subfloat[Taxa de cobertura]{
\includegraphics[width=0.45\textwidth]{figuras/qt-coverage.pdf}
\label{subfig-1:coverage}
}
\quad %espaco separador
\subfloat[Tempo de verificação]{
\includegraphics[width=0.45\textwidth]{figuras/qt-time.pdf}
\label{subfig-2:time}
}
\caption{Comparação entre solucionadores SMT.}
\label{figure:solver-comparison}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Verificação dos resultados para \textit{esbmc--qt}}
\label{sec:evaluation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Todos os casos de teste presentes na suite de teste \textit{esbmc--qt} foram verificados de forma automática por ESBMC$++$ com o objetivo de analisar a sua corretude e eficácia. Além da comparação entre solucionadores SMT descrita acima, uma análise a cerca do desempenho entre ferramentas de verificação distintas também foi realizada. Como já mencionado, não existe uma ferramenta de verificação que verifique o \textit{framework} multiplataforma Qt e nem um modelo operacional semelhante ao proposto neste trabalho (QtOM) utilizando a linguagem C$++$. No entanto, devido à versatilidade de QtOM, também é possível conectá-lo ao processo de verificação de outros verificadores de modelo como LLBMC~\cite{Florian12} e DIVINE~\cite{BBH13}, cuja base deste processo é a tradução do código fonte em um representação intermediária denominada LLVM. Dessa forma, QtOM é usado como apoio em seus processos de tradução, pois, o \textit{bitcode} que logo em seguida é produzido, contém informações a cerca do código fonte utilizado na verificação e do modelo operacional proposto (QtOM). Por fim, foi feito uma comparação em relação ao desempenho de LLBMC e ESBMC$++$, que são verificadores baseados em técnicas SMT, e DIVINE, que emprega uma verificação de modelos através estados explícitos. Inicialmente, houve uma tentativa de se realizar também uma comparação utilizando o verificador CBMC~\cite{CBMC14} junto com o modelo operacional proposto (QtOM), mas devido a falhas do verificador em relação a verificação da linguagem C$++$ não foi possível realizar as verificações previstas, isto já havia sido relatado em trabalhos anteriores por Ramalho \textit{et al.}~\cite{ECBS13} e Merz \textit{et al.}~\cite{Florian12}, o que ocasionou em sua remoção durante o processo de avaliação.

As ferramentas utilizadas foram executadas seguindo três roteiros. Um para ESBMC$++$ que identifica a partir de um arquivo seus parâmetros iniciais e realiza sua execução\footnote{esbmc *.cpp -\/-unwind $<$bound$>$  -\/-no-unwinding-assertions -I /home/libraries/ {\tt-\tt-}memlimit 14000000 {\tt-\tt-}timeout 600}, outro para LLBMC que usando CLang\footnote{/usr/bin/clang++ -c -g -emit-llvm *.cpp -fno-exceptions}~\cite{CLANG} compila o código fonte desejado criando seu \textit{bitcode} e logo em seguida, também a partir de um arquivo identifica seus parâmetros iniciais e realiza a sua execução\footnote{llbmc *.cpp --ignore-missing-function-bodies --max-loop-iterations=$<$bound$>$ --no-max-loop-iterations-checks} e outro para DIVINE que também pré-compila os códigos fontes em C$++$ criando seus respectivos \textit{bitcode}\footnote{divine compile --llvm -o main.bc *.cpp} para que em seguida realize sua verificação sobre eles\footnote{divine verify main.bc --max-time=600 --max-memory=14000 -d}. O desdobramento de loops é definido para cada ferramenta, isto é, o valor de $<$bound$>$ varia entre os casos de teste. Por enquanto, LLBMC não suporta tratamento de exceção e os \textit{bitcodes} que foram criados estavam com a opção \textit{-fno-exceptions} ativa em seu compilador. Vale ressaltar, que se está opção estiver ativa, LLBMC sempre abortará durante seu processo de verificação.

A Tabela~\ref{table:results-of-ESBMC} mostra os resultados experimentais para as junções entre QtOM e LLBMC, DIVINE e ESBMC$++$ usando Boolector como seu principal solucinador SMT. \textit{TC} representa o número de programas Qt/C$++$, \textit{L} representa a quantidade total de linhas de código, \textit{Time} representa o tempo total da verificação, \textit{P} representa o número de casos de teste sem defeitos (\textit{i.e.}, resultados positivos corretos), \textit{N} representa o número de casos de teste com defeitos (\textit{i.e.}, resultados negativos corretos), \textit{FP} representa o número falsos positivos obtidos (\textit{i.e.}, a ferramenta relata programas que estão corretos como incorretos), \textit{FN} representa o número de falsos negativos obtidos (\textit{i.e.}, a ferramenta relata programas incorretos como corretos) e \textit{Fail} representa o número de erros internos obtidos durante a verificação (\textit{e.g.}, erros de análise). Vale ressaltar que ESBMC$++$ utilizando Boolector não apresenta estouro de memória e tempo em qualquer caso de teste utilizado.

\begin{table}[!htb]
%\begin{adjustwidth}{-0.5cm}{}
\renewcommand\arraystretch{1.18}
\setlength{\tabcolsep}{0.9pt}
\begin{center} {\small
\begin{tabular}{|l|l|r||r|r|r|r|r|r||r|r|r|r|r|r||r|r|r|r|r|r|r|}
\hline
& & & \multicolumn{6}{c||}{ESBMC$++$ v1.25.4}  & \multicolumn{6}{c||}{LLBMC v2013.1}  & \multicolumn{6}{c|}{DIVINE v3.3.2} \\\cline{4-21}
 \textbf{Testsuite}    &\textbf{TC}	& \textbf{L}	& \textbf{Time} 	& \textbf{P}  	& \textbf{N}  	& \textbf{FP} 	& \textbf{FN}  & \textbf{Fail}  	& \textbf{Time} 	& \textbf{P}  	& \textbf{N}  	& \textbf{FP} 	& \textbf{FN}  & \textbf{Fail} & \textbf{Time} 	& \textbf{P}  	& \textbf{N}  	& \textbf{FP} 	& \textbf{FN}  & \textbf{Fail} \\\hline
QHash 	   	& 74  	& 1170  	& 117.2   		& 33  	& 33  	& 4  		& 4	  	& 0   			& 37.13   		& 31  	& 37  	& 0  		& 6	  	& 0   		& 1432.5   	& 32  	& 33  	& 0  		& 1	  	& 8 \\ % OK
\hline
QLinkedList 	& 87 		& 1700  	& 77.0  		& 40   	& 39 		& 2   		& 2    	& 4  			& 23.3   		& 18  	& 41 		& 2	  	& 26	  	& 0  	         & 1907.6	   	& 30  	& 42  	& 1  		& 14	  	& 0    \\ % OK
\hline	
QList 		& 124  	& 2317  	& 102.1  		& 53 		& 55 		& 7   		& 9  	 	& 0  			& 19.4   		& 28  	& 56  	& 0	  	& 28	  	& 12  	& 2599.7   	& 52  	& 56  	& 0 		& 4	  	& 12    \\ % OK
\hline
QMap 		& 99  	& 1989  	& 277.2  		& 42 		& 39 		& 10   	& 8   		& 0  			& 406.4   		& 41  	& 46  	& 2  		& 8	  	& 2   		& 2109.9   	& 40  	& 44  	& 0  		& 5	  	& 10   \\ % OK
\hline 
QMultiHash 	& 24  	& 363   	& 186.4   		& 12    	& 12   	& 0   		& 0    	& 0  			& 30.8   		& 12  	& 12  	& 0  		& 0	  	& 0   		& 466.3     	& 13  	& 12  	& 0  		& 0	  	& 0   \\ % OK
\hline
QMultiMap 	& 26   	& 504   	& 136.9		& 13  	& 13   	& 0   		& 0    	& 0  			& 32.0   		& 13  	& 13  	& 0  		& 0	  	& 0   		& 549.9     	& 14  	& 13  	& 0  		& 0	  	& 0    \\ % OK
\hline
QQueue  		& 16   	& 299  	& 191  		& 8   		& 8  		& 0   		& 0    	& 0  			& 3.9   		& 8    	& 8    	& 0  		& 0	  	& 0   		& 339.7     	& 8  	        & 8    	& 0  		& 0	  	& 0    \\ % OK
\hline
QSet 		& 94   	& 1702  	& 500.5  		& 43   	& 43  	& 4  		& 4    	& 0  			& 132.6   		& 40  	& 44  	& 1  		& 5	  	& 4   		& 1897.2   	& 40  	& 41  	& 0  		& 0	  	& 13   \\ % OK
\hline
QStack 		& 12  	& 280  	& 14.5 		& 5 		& 5 		& 0  		& 0   		& 2  			& 2.2   		& 6	   	& 5    	& 1  		& 0	  	& 0   		& 262.1     	&6  	        & 6  	        	& 0  		& 0	  	& 0     \\ % OK
\hline
QVector 		& 152  	& 2582  	&157.3 		& 67  	&68  		& 7  		&8  		& 2  			& 1825.7  		& 44  	& 73  	& 0 		& 29	  	& 6    	& 3057.5   	& 68  	& 72  	& 0  		& 6	  	& 6  \\ % OK
\hline\hline
{\bf Total} 		& 708 	& 12903 	& 1760		& 316 	& 315	& 34 		& 35   	& 8  			& 2513.5  		& 241  	& 335  	& 6 		& 102	& 24  	& 14722.4   	& 303  	& 327  	& 1  		& 30	  	& 49  \\ % OK
\hline
\end{tabular} }
\end{center}
\caption{Resultados obtidos da comparação entre ESBMC$++$ v1.25.4 (usando Boolector como solucionador SMT), LLBMC v2013.1 e DIVINE v3.3.2.}
\label{table:results-of-ESBMC}
%\end{adjustwidth}
\end{table}

De acordo com a tabela acima, apenas $1,1$\% dos casos de teste com ESBMC$++$ alegaram falhas durante sua verificação, isto ocorre quando a ferramenta não é capaz de realizar a verificação de um determinado programa devido a erros internos encontrados. DIVINE e LLBMC apresentam taxas de falha de $6,9$\% e $3,4$\%, respectivamente, por conta de tais ferramentas não conseguirem criar os \textit{bitcodes} dos programas utilizados ou durante verificação realizada foi relatado que houve um estouro de memória ou de tempo. Em relação aos resultados $FP$, DIVINE obteve o melhor desempenho seguido por LLBMC e ESBMC$++$. Contudo, ESBMC$++$ obteve a taxa mais baixa em relação aos resultados de falsos negativos ($FN$) seguido por DIVINE e por fim LLBMC, isso ocorre devido a forma que os \textit{iterators} estão implementados no modelo operacional proposto (QtOM), através de ponteiros e vetores com o objetivo de simular seus comportamentos de forma real e de acordo com o visto no capítulo~\ref{chapter:container-model}. No entanto, a estrutura criada não cobre todos os comportamentos descritos na documentação do \textit{framework}. Em particular, quando uma remoção de um elemento é realizada em um \textit{container} em que existe mais de um \textit{iterator} apontando para ele, todos os \textit{iterators} que apontam para o elemento que foi removido serão perdidos. Desta forma, este comportamento afetará as pós-condições de um programa que influenciam diretamente nos resultados obtidos em relação a \textit{FP} e \textit{FN}. Vale ressaltar que vetores e ponteiros têm sido extensivamente utilizados, de modo a obter estruturas simples, isto é, sem classes e \textit{structs} em sua representação o que diminui a complexidade do processo de verificação (ver seção~\ref{sec:postconditions}). Por fim, os resultados da combinação entre ESBMC$++$ e QtOM em um verificador robusto, ainda possui algumas lacunas a serem preenchidas a cerca do suporte a linguagem C$++$ como descrito por Ramalho \textit{et al.}~\cite{ECBS13}.

Vale mencionar que o nível de complexidade ao se verificar o código fonte de um programa aumenta de acordo com a quantidade de linhas que ele tiver, assim como, a quantidade de estruturas que possuir. No entanto, de acordo como mostrado na figura~\ref{figure:time}, os conjuntos de teste QMap e QSet apresentam os maiores tempos durante o processo de verificação ao se utilizar ESBMC$++$, apesar de QVector ser o mais extenso conjunto de casos de teste existente. Isso acontece devido ser analisado a quantidade de loops presente no programa e não somente o número de linhas de código que ele possui, o que afeta diretamente os tempos de verificação. Na realidade, as estruturas internas associadas ao modelo operacional das classes \textit{QMap} e \textit{QSet} contém mais loops do que as demais, desta forma, obtém-se tempos de verificação mais longos. Como também visto na figura~\ref{figure:time}, LLBMC apresenta um maior tempo de verificação ao se utilizar o conjunto de teste QVector, na qual, isto ocorre devido a dois casos de teste em que houve estouro do tempo estimado para que seja realizada a verificação. Além disso, DIVINE é a ferramenta que apresenta o menor desempenho entre as citadas, pois, seu processo de criação do \textit{bitcode} é mais custoso do que a realização da verificação sobre o mesmo. Dessa forma, os conjuntos de teste com mais programas a serem analisados obtiveram os maiores tempos que no caso são \textit{QVector}, \textit{QList}, \textit{QMap}, \textit{QLinkedList} e \textit{QSet}.

\begin{figure}[htb]
  \centering
  \includegraphics[width=4.5in]{figuras/Time.pdf}
  \caption{Comparação entre os tempos de verificação em relação a ESBMC$++$, LLBMC e DIVINE.}
  \label{figure:time}
\end{figure}

A figura~\ref{figure:coverage} mostra que todos os verificadores que obtiveram uma taxa de corbetura acima de 80\% para os \textit{containers} do tipo associativo. Contudo, LLBMC não se manteve com a mesma taxa ao analisar os containers do tipo sequencial. Vale ressaltar que todos os casos de teste a partir dos conjuntos de teste QMultiMap e QMultiHash foram verificados corretamente por todos os verificadores utilizados. Os conjuntos de teste QHash, QMap e QSet, por sua vez, apresentaram uma taxa média de $6,7$\% para resultados falsos positivos e falsos negativos, ou seja, de $3$ a $18$ casos de teste dos $267$ casos de teste são considerados falsos positivos ou falsos negativos, isso ocorre devido as limitações na representação interna dos \textit{iterators}. Além disso, LLBMC e DIVINE, respectivamente, não conseguiram verificar cerca de $4,5$\% e $13,9$\% dos casos de teste dos containers associativos, ou seja, $12$ e $13$ dos $267$ casos de teste não conseguiram ser verificados devido as falhas no processo de criação do \textit{bitcode}. Em relação aos \textit{containers} do tipo sequencial, LLBMC apresentou baixas taxas de cobertura para os conjuntos de teste \textit{QVector}, \textit{QLinkedList} e \textit{QList}, taxas a cerca de $67,7$\% a $77$\%, ou seja, $84$/$117$ dos $124$/$152$ casos de teste,respectivamente. Além disso, cerca de $22,9$\% dos casos de teste ($83$ dos $363$ analisados) apresentaram resultados falsos negativos devido também a problemas com a representação interna dos \textit{iterators}. Vale ressaltar, que cerca de $5$\% dos casos de teste ($18$ dos $363$ analisados) não haviam sido verificados por LLBMC, uma vez que não foi capaz de criar os \textit{bitcodes} desejados. ESBMC$++$ e DIVINE, por sua vez, apresentaram uma taxa de erro de no máximo de $6,6$\%, ou seja, $24$ dos $363$ casos de teste para os conjuntos de teste QVector, QLinkedList e QList apresentam erros devido a erros de análise em suas pós-condições. Além disso, todos os casos de teste dos conjuntos de teste QQueue e QStack foram verificados corretamente, com exceção de dois casos presente em QStack, pois, ao se utilizar o solucinador Boolector com a ferramenta ESBMC$++$ não foi possível obter-se uma solução para as fórmulas SMT criadas para os casos analisados. 

\begin{figure}[htb]
  \centering
  \includegraphics[width=4.5in]{figuras/Coverage.pdf}
  \caption{Comparação entre a taxa de cobertura em relação a ESBMC++, LLBMC e DIVINE.}
  \label{figure:coverage}
\end{figure}

Os conjuntos de teste QList, QMap, QVector e QSet possuem mais resultados falsos positivos e negativos em seus testes ao se utilizar ESBMC$++$ do que as outras ferramentas. A taxa de cobertura a cerca dos casos de teste verificados corretamente se encontra em torno de $80$\% a $90$\%, respectivamente, o que demonstra a eficácia em relação a verificação realizada uma vez que cada caso de teste verifica características diferentes de diferentes containers.

Vale ressaltar que ESBMC$++$ foi capaz de identificar cerca de $89,3$\% dos erros nos casos de teste utilizados (\textit{i.e.}, $631$ dos $708$ casos de testes utilizados possuem erros), o que demonstra também eficácia da metodologia proposta. Similarmente, LLBMC e DIVINE apresentam, respectivamente, taxas com $81,4$\% e $89$\% (\textit{i.e.}, $576$ e $630$ dos $708$ casos de teste utilizados possuem erros), o que também demonstra uma boa adequação do modelo operacional proposto (QtOM) combinado com outras ferramentas de verificação. Como consequência, a metodologia proposta não apenas se limita a uma determinada ferramenta, podendo-se adaptar para aplicações específicas em que algumas abordagens sejam mais adequedas do que outras. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Verificação dos resultados para aplicações reais}
\label{sec:realqt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Dado que o conjunto de casos de teste proposto possui como objetivo verificar propriedades específicas dos módulos pertencentes ao \textit{framework} multiplataforma Qt, também é necessário incluir resultados de verificações que envolvam aplicações reais. Os parágrafos seguintes descrevem as respectivas aplicações e seus resultados associados.

A aplicação chamada \textit{Locomaps}~\cite{locomaps} é um exemplo de programa que utiliza o \textit{framework} multiplataforma Qt e exibi imagens de satélite, terrenos, mapas de ruas, serviço de planejamento de mapas em mosaicos e possui um integração com GPS \textit{Qt Geo}. Utilizando o mesmo código fonte está aplicação pode ser compilada e executada nos principais sistemas operacionais existentes (Mac OS X, Linux e Windows). Está aplicação possui duas classes com $115$ linhas de códigos no total, utilizando Qt/C$++$ e usando cinco APIs diferentes do framework Qt ( \textit{QApplication}, \textit{QCoreApplication}, \textit{QDesktopWidget}, \textit{QtDeclarative} e \textit{QMainWindow}). Vale mencionar que o código escrito em Qt/C$++$ desta aplicação, as APIs e as bibliotecas utilizadas são considerados no processo de verificação, assim como, as propriedades relacionadas a eles. 

ArcGIS~\cite{ArcGIS} para as forças armadas é um plataforma geográfica que é utilizada para criar, organizar e compartilhar materiais geográficos com usuários que utilizam mapas inteligentes online. A partir disso, GeoMessage Simulator~\cite{geomessage} possui como entrada de dados arquivos XML e cria em diferentes frequências datagramas utilizando o protocolo de datagramas por usuário(\textit{em inglês}, User Datagram Protocol(UDP)) para aplicações ArcGIS e componentes do sistema. \textit{GeoMessage Simulator} também é uma aplicação multi-plataforma que contém $1209$ linhas de códigos em Qt/C$++$ que utiliza $20$ diferentes APIs do \textit{framework} multiplataforma Qt englobando várias características, tais como o sistema de eventos de Qt, \textit{strings}, manipulação de arquivos e \textit{widgets}. Vale ressaltar que \textit{GeoMessage Simulator} usa duas classes, \textit{QMutex} e \textit{QMutexLocker}, relacionadas ao módulo \textit{Qt Threading} que possui classes para programas concorrentes. Tais classes foram utilizados na aplicação para travar ou destravar mutexes e, o mais importante, ESBMC$++$ é capaz de verificar adequadamente esses tipos de estruturas. No entanto, o modelo operacional proposto (QtOM) não fornece um suporte completo para o módulo \textit{Qt Threading} ainda.

ESBMC$++$ junto ao modelo operacional proposto (QtOM) foi aplicado para verificar as aplicações \textit{Locomaps} e \textit{GeoMessage Simulator} buscando verificar as seguintes propriedades: violação dos limites de um array, estouros aritméticos, divisão por zero, segurança de ponteiro e outras propriedades específicas do framework definidas em QtOM de acordo com o capítulo~\ref{chapter:smt-bmc}. Além disso, ESBMC$++$ foi capaz de identificar completamente o código-fonte de cada aplicação, utilizando cinco diferentes módulos de QtOM para \textit{Locomaps} e vinte módulos para \textit{GeoMessage Simulator}, ou seja, cada módulo de QtOM usado correspondia a uma API utilizada pela aplicação que seria verificada. O processo de verificação de ambas as aplicações foi totalmente automático e a metodologia proposta levou aproximadamente $6,7$ segundos para gerar $32$ condições de verificação (\textit{em inglês}, Verification Conditional(VC)) para \textit{Locomaps} e $16$ segundos para gerar $6421$ VCs para \textit{GeoMessage Simulator} em um comum \textit{desktop}. Além disso, ESBMC$++$ não relata caso haja qualquer falso negativo mas foi capaz de encontrar bugs semelhantes em ambas as aplicações, as quais foram confirmadas pelos desenvolvedores e são explicadas abaixo.

\begin{figure}[h]
\centering
\begin{minipage}{0.60\textwidth}
\begin{lstlisting}
int main(int argc, char *argv[]) {
  QApplication app(argc, argv);
  return app.exec();
}
\end{lstlisting}
\end{minipage}
\caption{Fragmento de código do arquivo principal da aplicação {\it Locomaps}.}
\label{fig:Fig6}
\end{figure}

A figura~\ref{fig:Fig6} mostra um fragmento de código retirado do principal arquivo da aplicação \textit{Locomaps} que utiliza a classe \textit{QApplication} que está presente no módulo \textit{QtWidgets}. Nesse caso em particular, se o parâmetro $argv$ não for corretamente inicializado, logo o construtor ao ser chamado pelo objeto $app$ não é executado de forma correta acarretando em falhas na aplicação (veja a linha2, na figura~\ref{fig:Fig6}). A fim de verificar está propriedade, ESBMC$++$ analisa dois \textit{assertions} em relação aos parâmetros de entrada da aplicação (veja as linhas $4$ e $5$, na figura~\ref{fig:Fig7}), avaliando-as como pré-condições. Um erro semelhante também foi encontrado na aplicação \textit{GeoMessage Simulator} e uma maneira possível para corrigir tal erro é sempre verificar, com instruções condicionais, se $argv$ e $argc$ são argumentos válidos antes de utiliza-las em uma operação.

\begin{figure}[h]
\centering
\begin{minipage}{0.60\textwidth}
\begin{lstlisting}
class QApplication {
  ...
  QApplication( int & argc, char ** argv ){
  __ESBMC_assert(argc > 0, ``Invalid parameter'');
  __ESBMC_assert(argv != NULL, ``Invalid pointer'');
  this->str = argv;
  this->_size = strlen(*argv);
  ...
 }
 ...
};
\end{lstlisting}
\end{minipage}
\caption{Modelo operacional para o construstor de $QApplication$().}
\label{fig:Fig7}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Resumo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Neste capítulo, inicialmente foi descrito como foi construida a configuração experimental utilizada, a qual, possui como objetivo avaliar a eficácia da metodologia proposta a cerca da verificação de programas que utilizam o \textit{framework} multiplaforma Qt a partir de um conjunto de testes denomidado \textit{esbmc--qt} que contém todos os casos de teste utilizadas na atual avaliação. Logo em seguida, foi descrito como foi realizado e avaliado a comparação entre os solucionadores SMT utilizados junto com ESBMC$++$ utilizando programas Qt/C$++$ \textit{single-thread}, isso foi realizado pois, solucionadores SMT podem afetar fortemente os resultados obtidos, uma vez que não existe homogeneidade em relação a abordagem de implementação e as lógicas suportadas. Além disso, também foi descrito os resultados obtidos a cerca da verificação de todos os casos de teste presentes na suite de teste \textit{esbmc--qt} utilizando ferramentas de verificação distintas (ESBMC$++$, LLBMC e DIVINE) com o objetivo de analisar a corretude e a eficácia do modelo operacional proposto junto dessas ferramentas. Por fim, foi descrito os resultados obtidos atráves da verificação de duas aplicações reais \textit{Locomaps} e \textit{GeoMessage Simulator} utilizando QtOM.

%Outros topicos
%\input{5_k-induction/algoritmo.tex}