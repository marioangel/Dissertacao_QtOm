%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Modelo Operacional para \textit{containers}}
\label{chapter:container-model}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Este capítulo descreve o processo de criação do modelo operacional QtOM enfatizando as classes \textit{containers} do \textit{framework} Qt. Inicialmente, na Seção~\ref{sec:introcap4} é descrito como está disposto as classes containers no \textit{framework} Qt, assim como, o seu uso em aplicações. Logo em seguida, na Seção~\ref{sec:language} é descrito a linguagem que foi utilizada como base para se criar as representações contidas em QtOM com o objetivo de formalizar a implementação de cada \textit{container}. Por fim, nas Seções~\ref{sec:sequential} e~\ref{sec:associative} é descrito como as classes containers foram divididas entre sequenciais e associativas, e o seu comportam no momento de sua utilização pelo modelo operacional através de lógica formal. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introdução}
\label{sec:introcap4}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

O módulo \textit{Qt Core} possui um subconjunto de classes denominado \textit{Qt Container}~\cite{Qt15} como alternativa para os \textit{containers} da \textit{Standard Template Library} (STL) disponíveis na linguagem C++~\cite{Iso2003}. Por exemplo, durante o desenvolvimento de uma determinada aplicação, é necessário a criação de uma pilha de tamanho variável para o armazenamento de objetos do tipo \textit{QWidgets}, neste caso, uma alternativa seria o uso da classe \textit{QStack} que implementa um \textit{container} com a política LIFO (do inglês, \textit{last-in, first-out}) (\textit{e.g.}, \textit{QStack}$<$\textit{QWidget}$>$). Além disso, tais \textit{containers} também fazem uso de estruturas denominadas \textit{iterators} no estilo Java/STL, de modo a se deslocar ao longo dos dados armazenados no \textit{container} criado.  

Desta forma, esse subconjunto de classes pode ser classificado em dois subgrupos: sequenciais e associativos, dependendo da estrutura de armazenamento implementada. Neste contexto, as classes \textit{QList}, \textit{QLinkedList}, \textit{QVector}, \textit{QStack} e \textit{QQueue} são classificadas como \textit{containers} sequenciais, enquanto as classes \textit{QMap}, \textit{QMultiMap}, \textit{QHash}, \textit{QMultiHash} e \textit{QSet} são classificadas como \textit{containers} associativos.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linguagem Base}
\label{sec:language}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Com o intuito de implementar o modelo operacional para as classes que compõe o \textit{Qt Container}, a formalização da linguagem base descrita por Ramalho \textit{et al.}~\cite{ECBS13} é utilizada e se estende até a formulação das propriedades $\mathcal{C}$ e $\mathcal{P}$. Contudo, tal linguagem foi adaptada, neste trabalho, com o objetivo de formular adequadamente a verificação de ambos tipos de \textit{containers} (\textit{i.e.}, sequencial ou associativo) como mostrado na Figura~\ref{ccl-fig}.  

\begin{figure}[htb]
\[\begin{array}{r@{\:\:}r@{\:\:}l}
  V  & ::= &
    v \:|\: \mathit{I_v} \:|\: \mathit{P_v}
\\[0.5ex]
  K  & ::= &
    k \:|\: \mathit{I_k} \:|\: \mathit{P_k}
\\[0.5ex]
   \mathit{I} & ::= &
     i \:|\: \mathit{C.begin()} \:|\: \mathit{C.end()}
\\  & | &
     \mathit{C.insert(\mathit{I}, \mathit{V}, \mathbb{N})} \:|\: \mathit{C.erase(\mathit{I})} \:|\: \mathit{C.search(\mathit{V})}
\\  & | &
     \mathit{C.insert(\mathit{K}, \mathit{V})} \:|\: \mathit{C.search(\mathit{K})}
\\[0.5ex]
   P  & ::= &
     p \:|\: P (+ \:|\: - ) P
       \:|\: \mathit{C_k} \:|\: \mathit{C_v} \:|\: \mathit{I_k} \:|\: \mathit{I_v}
\\[0.5ex]
   C  & ::= &
     c 
\\[0.5ex]
  \mathbb{N}  & ::= &
     n \:|\: \mathbb{N} (+ \:|\: * | \ldots) \mathbb{N}
       \:|\: \mathit{I_{pos}}
       \:|\: \mathit{C_{size}}
  \end{array}
\]
  \caption{Sintaxe da linguagem adaptada, base para a descrição formal dos \textit{containers}.}
  \label{ccl-fig}
\end{figure}

De acordo com a Figura~\ref{ccl-fig}, os elementos básicos estão divididos em dois domínios sintáticos: $\mathit{V}$ para valores e $\mathit{K}$ para as chaves. No entanto, os demais domínios, $\mathit{I}$, $\mathit{P}$, $\mathbb{N}$ e $\mathit{C}$ são mantidos por \textit{iterators}, ponteiros, índices inteiros e expressões \textit{container} adequadas, respectivamente. Assim, as variáveis $\mathit{k}$ do tipo $\mathit{K}$ e $\mathit{v}$ do tipo $\mathit{V}$ são adicionadas. Dessa forma, a notação $\mathit{I_v}$ representa um valor armazenado em um \textit{container} em uma posição direcionada pelo \textit{iterator} $\mathit{I}$ e $\mathit{I_k}$ representa uma chave armazenada em um \textit{container} em uma posição direcionada também pelo \textit{iterator} $\mathit{I}$. Tais notações são abreviações para $\mathit{store(i,I_{pos},I_v)}$ e $\mathit{store(i,I_{pos},I_k)}$, respectivamente, onde a expressão $\mathit{store}(t, f, v)$ indica \textit{container} $t$ que no campo $f$ possui um valor $v$. Da forma similar, $\mathit{P_k}$ e $\mathit{P_v}$ representam ponteiros para a chave e o valor, respectivamente.

Além disso, três outros métodos foram incluídos com o objetivo de descrever as operações realizadas em cada \textit{container}. O método $\mathit{C.insert(k, v)}$ insere um valor $\mathit{v}$ no \textit{container} $C$ com uma chave correspondente $\mathit{k}$ e possui como retorno um \textit{iterator} que aponta para o novo elemento inserido. O método $\mathit{C.search(k)}$ retorna um \textit{iterator} que aponta para a primeira evidência de um elemento com uma chave $\mathit{k}$ correspondente. De modo semelhante, $\mathit{C.search(v)}$ também retorna um \textit{iterator} que aponta para a primeira evidência de um elemento com um valor $\mathit{v}$ correspondente. No entanto, caso não exista nenhuma chave ou valor correspondente durante a operação com tais métodos, os mesmos retornarão $\mathit{C.end()}$, o qual corresponde ao \textit{iterator} que aponta para a posição imediatamente posterior ao último elemento. Por fim, $\mathit{C_k}$ é um endereço de memória que armazena o início das chaves dos \textit{containers}, assim como, $\mathit{C_v}$ é usado para armazenar os valores dos \textit{containers}.

É importante ressaltar que, todas demais operações provenientes da linguagem base mencionada são utilizadas aqui de acordo como descrito por Ramalho \textit{et al.}~\cite{ECBS13}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\textit{Containers} sequenciais}
\label{sec:sequential}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textit{Containers} sequenciais tem como objetivo armazenar elementos em uma determinada ordem~\cite{Deitel}. De acordo com a documentação do Qt~\cite{Qt15}, \textit{QList} é a classe \textit{container} mais utilizada e possui uma estrutura em formato de lista encadeada. Da mesma forma, \textit{QLinkedList} também possui um estrutura em forma de lista, embora seja acessada através de \textit{iterators} ao invés de índices inteiros. Na classe \textit{QVector}, há presente uma estrutura de \textit{array} expansível e, por fim, \textit{QStack} e \textit{QQueue} fornecem estruturas que implementam diretivas como LIFO e FIFO (em inglês, \textit{first-in, first-out}), respectivamente.

Para simular adequadamente os \textit{containers} sequenciais, os modelos propostos utilizam da linguagem base descrita na Seção~\ref{sec:language}. Os \textit{containers} sequenciais são implementados a partir de um ponteiro $\mathit{C_v}$ para os valores do \textit{container} e também com um $\mathit{C_{size}}$, o qual é utilizado para representar o tamanho do respectivo \textit{container} (onde $\mathit{C_{size}} \in \mathbb{N}$). Dessa forma, os \textit{iterators} são modelados por meio de duas variáveis, uma do tipo $\mathbb{N}$ que é denominada de $\mathit{i_{pos}}$ e contém o valor do índice apontado por um \textit{iterator} e outra do tipo $P$ que é chamado por $\mathit{I_v}$ e aponta para um \textit{container} subjacente.

Vale ressaltar que todos os métodos, a partir dessas bibliotecas, podem ser expressos em variações simplificadas de três operações principais, \textit{insertion}($\mathit{C.insert(\mathit{I}, \mathit{V}, \mathbb{N})}$), \textit{deletion}($\mathit{C.erase(\mathit{I})}$) e \textit{\textit{search}}($\mathit{C.search(\mathit{V})}$). A partir da transformação SSA, os efeitos adversos sobre \textit{iterators} e \textit{containers} são explícitos para que as operações retornem novos \textit{iterators} e \textit{containers}.

Por exemplo, um \textit{container} $c$ com uma chamada \textit{c.search}($v$) representa uma pesquisa pelo elemento $v$ no respectivo \textit{container}. Deste modo, se esse elemento for encontrado, é retornado um \textit{iterator} que aponta para o respectivo elemento, caso contrário, é retornado um \textit{iterator} que aponta para a posição imediatamente posterior ao último elemento do \textit{container} (\textit{i.e.}, $\mathit{c.end()}$). Desta forma, a instrução ``$\mathit{c.search}(v);$'' torna-se ``$(c',i')=\mathit{c.search}(v);$'' que possuem efeitos adversos de forma explícita. Assim, a função de tradução $\mathcal{C}$ descreve premissas que estão relacionadas com o ``antes" e o ``depois" das respectivas versões das variáveis do modelo. Na verdade, notações com apóstrofe (\textit{e.g.}, $c'$ and $i'$) representam o estado das variáveis do modelo, após realizar a execução da respectiva operação; notações simplificadas (\textit{e.g.}, $c$ and $i$) representam os estados anteriores. Além disso, $select(c, i = lower_{bound} \ldots i = upper_{bound})$ representa uma expressão de \textit{loop} (\textit{e.g.}, $for$ e $while$), onde cada valor de $c$, a partir da posição $lower_{bound}$ até $upper_{bound}$, será selecionado. Da mesma forma, $store(c_{1}, lower_{bound}^{1},select(c_{2},lower_{bound}^{2}))$\\$ \ldots store(c_{1},upper_{bound}^{1},select(c_{2},upper_{bound}^{2}))$ também representa uma expressão de \textit{loop}, onde cada valor de $c_{2}$, a partir de posição $lower_{bound}^{2}$ até a posição $upper_{bound}^{2}$ serão armazenados em $c_{1}$ nas posições $lower_{bound}^{1}$ até $upper_{bound}^{1}$, respectivamente. Sendo assim,
%
\[\begin{array}{lll}
\multicolumn{3}{l}{{\mathcal{C}}((c',i')=c\mathit{.search}(v)):=}\\
  & \multicolumn{2}{l}{\wedge\:i' := c.\textit{begin}()}\\
  & \wedge\: g_0 := &\!\!\!\!\textit{select}(c_v, i_{pos} = 0 \ldots i_{pos} = c_{size} - 1) == v \\
%  & & \textit{select}(\ldots(\textit{select}(c_v, i_{pos} = 0),\\
%  & & \:\:\:\:\:\:\ldots,\\
%  & & i_{pos} = c_{size} - 1))) == v \\
  & \multicolumn{2}{l}{\wedge\:{i'}_{pos} := \textit{ite}(g_0, i_{pos}, c_{size})}\\
  & \multicolumn{2}{l}{\wedge\:{i'}_v := {c'}_v.}\\
\end{array}\]

Com relação aos \textit{containers} sequenciais, os métodos $\mathit{C.insert(\mathit{I}, \mathit{V}, \mathbb{N})}$ e $\mathit{C.erase(\mathit{I})}$ se comportam como descrito por Ramalho \textit{et al.}~\cite{ECBS13}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\textit{Containers} Associativos}
\label{sec:associative}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

O grupo dos \textit{containers} associativos possui cinco classes: \textit{QMap}, \textit{QMultimap}, \textit{QHash}, \textit{QMultiHash} e \textit{QSet}. \textit{QMap} tem como abordagem um vetor associativo que conecta cada umas das chaves, de um certo tipo $K$, a um valor de um certo tipo $V$, onde as chaves associadas são armazenadas em ordem. Por um lado, \textit{QHash} apresenta um comportamento similar ao \textit{QMap}, contudo os dados armazenados possuem uma ordem arbitrária. \textit{QMultiMap} e \textit{QMultihash} representam respectivamente subclasses de \textit{QMap} e \textit{QHash}, no entanto, ambas classes permitem o armazenamento de valores replicados. Por fim, \textit{QSet} armazena objetos que estão associados a um conjunto de valores ordenados.

Com o intuito de implementar \textit{containers} associativos, um ponteiro $c_v$ é definido para os valores armazenados, um ponteiro $c_k$ é utilizado para armazenar as chaves do respectivo \textit{container} e uma variável $c_{size}$ é utilizada para guardar a quantidade de elementos inseridos. Em especial, $c_k$ e $c_v$ estão conectados por meio de um índice, ou seja, dado um \textit{container} $c$ que contém uma chave $k$ e um valor $v$ assume-se que

\[\begin{array}{r@{\:\:}c@{\:\:}l}
\left[\forall \omega \in \mathbb{N} | 0 \leq \omega < c_{size}\right]
\end{array}
\]

\noindent e

\[\begin{array}{r@{\:\:}c@{\:\:}l}
k \rightarrow v \iff select\left(c_k,\omega\right) = k \wedge select\left(c_v,\omega\right) = v,
\end{array}
\]

\noindent onde $(k \rightarrow v)$ indica que uma chave $k$ é associada a um valor $v$ and $\omega$ representa uma posição válida em $c_k$ e $c_v$. Além disso, a função \emph{select(a, i)} indica o valor de $a$ em um índice $i$~\cite{ECBS13}. Novamente, todas as operações dessas bibliotecas podem ser expressadas a partir de uma variação simplificada das três principais operações citadas na Seção~\ref{sec:sequential}.

Portanto, a operação de inserção para \textit{containers} associativos pode ser realizada de duas maneiras diferentes. Em primeiro lugar, se a ordem não importa, um novo elemento é inserido no final de $c_k$ e $c_v$. Desta forma, dado um container $c$, o método $c.insert(k,v)$ ao ser chamado realiza inserções de elementos no \textit{container} $c$ com um o valor $v$ e associado a uma chave $k$, porém se $k$ já existe, ele substitui o valor associado a $k$ por $v$ e retorna um \textit{iterator} que aponta para o elemento inserido ou modificado. Deste modo,
%
\[\begin{array}{lll}
\multicolumn{3}{l}{{\mathcal{C}}((c',i')=c\mathit{.insert}(k,v)):=}\\
  & \multicolumn{2}{l}{\wedge\:{c'}_{size} := {c}_{size} + 1}\\
  & \multicolumn{2}{l}{\wedge\:i' := c.\textit{begin}()}\\
  & \wedge\: g_0 := &\!\!\!\!\textit{select}(c_k, i_{pos} = 0 \ldots i_{pos} = c_{size} - 1) == k \\
  %& \wedge\: g_0 := &\!\!\!\!(\textit{select}(\ldots(\textit{select}(\\
  %& & \textit{select}(\ldots(\textit{select}(c_k, i_{pos} = 0),\\
  %& & \:\:\:\:\:\:\ldots,\\
  %& & i_{pos} = c_{size} - 1))) = k \\
  & \multicolumn{2}{l}{\wedge\:{i'}_{pos} := \textit{ite}(g_0, i_{pos}, c_{size})}\\
  & \wedge\: {c'}_k := &\!\!\!\!\textit{store}(c_k,{i'}_{pos} + 1, \textit{select}(c_k, {i'}_{pos})),\\
  & & \:\:\:\:\:\:\ldots,\\
  & & \textit{store}(c_k, c_{size}, \textit{select}(c_k, c_{size} - 1)))\\
  %& \wedge\: {c'}_k := &\!\!\!\!\textit{store}(\ldots(\textit{store}(c_k\\
  %& & {i'}_{pos} + 1, \textit{select}(c_k, {i'}_{pos})),\\
  %& & \:\:\:\:\:\:\ldots,\\
  %& & c_{size}, \textit{select}(c_k, c_{size} - 1)))\\
  & \wedge\: {c'}_v := &\!\!\!\!\textit{store}(c_v,{i'}_{pos} + 1, \textit{select}(c_v, {i'}_{pos})),\\
  & & \:\:\:\:\:\:\ldots,\\
  & & \textit{store}(c_v, c_{size}, \textit{select}(c_v, c_{size} - 1)))\\
  %& \wedge\: {c'}_v := &\!\!\!\!\textit{store}(\ldots(\textit{store}(c_v\\
  %& & {i'}_{pos} + 1, \textit{select}(c_v, {i'}_{pos})),\\
  %& & \:\:\:\:\:\:\ldots,\\
  %& & c_{size}, \textit{select}(c_v, c_{size} - 1)))\\
  & \multicolumn{2}{l}{\wedge\:{c'}_k := \textit{store}(c_k, {i'}_{pos}, k)}\\
  & \multicolumn{2}{l}{\wedge\:{c'}_v := \textit{store}(c_v, {i'}_{pos}, v)}\\
  & \multicolumn{2}{l}{\wedge\:{i'}_k := {c'}_k}\\
  & \multicolumn{2}{l}{\wedge\:{i'}_v := {c'}_v.}\\
\end{array}\]
%

Em uma outra versão do método de inserção onde a ordem das chaves possuem importância. Todas as variáveis citadas acima são consideradas e uma comparação é realizada, a fim de assegurar que o novo elemento é inserido na ordem desejada. Assim,

%
\[\begin{array}{lll}
\multicolumn{3}{l}{{\mathcal{C}}((c',i')=c\mathit{.insert}(k,v)):=}\\
  & \multicolumn{2}{l}{\wedge\:{c'}_{size} := {c}_{size} + 1}\\
  & \multicolumn{2}{l}{\wedge\:i' := c.\textit{begin}()}\\
  & \wedge\: g_0 := &\!\!\!\!\textit{select}(c_k, i_{pos} = 0 \ldots i_{pos} = c_{size} - 1) > k \\
  & \wedge\: g_1 := &\!\!\!\!\textit{select}(c_k, i_{pos} = 0 \ldots i_{pos} = c_{size} - 1) == k \\
  & \multicolumn{2}{l}{\wedge\:{i'}_{pos} := \textit{ite}(g_0 \vee g_1, i_{pos}, c_{size})}\\
  & \wedge\: {c'}_k := &\!\!\!\!\textit{store}(c_k,{i'}_{pos} + 1, \textit{select}(c_k, {i'}_{pos})),\\
  & & \:\:\:\:\:\:\ldots,\\
  & & \textit{store}(c_k, c_{size}, \textit{select}(c_k, c_{size} - 1)))\\
  & \wedge\: {c'}_v := &\!\!\!\!\textit{store}(c_v,{i'}_{pos} + 1, \textit{select}(c_v, {i'}_{pos})),\\
  & & \:\:\:\:\:\:\ldots,\\
  & & \textit{store}(c_v, c_{size}, \textit{select}(c_v, c_{size} - 1)))\\
  & \multicolumn{2}{l}{\wedge\:{c'}_k := \textit{store}(c_k, {i'}_{pos}, k)}\\
  & \multicolumn{2}{l}{\wedge\:{c'}_v := \textit{store}(c_v, {i'}_{pos}, v)}\\
  & \multicolumn{2}{l}{\wedge\:{i'}_k := {c'}_k}\\
  & \multicolumn{2}{l}{\wedge\:{i'}_v := {c'}_v.}\\
\end{array}\]
%

Em casos onde chaves com vários valores associados são permitidos, a comparação feita será ignorada, caso seja verificado que já existe um elemento associado a respectiva chave analisada. Por fim, com o propósito de realizar uma exclusão, o método apagar, o qual é representado por $erase$($i$) onde $i$ é um \textit{iterator} que aponta para o elemento a ser excluído. Isso exclui o elemento apontado por $i$, movendo para trás todos os elementos seguidos pelo elemento que foi excluído. Deste modo,
%
\[\begin{array}{lll}
\multicolumn{3}{l}{{\mathcal{C}}((c',i')=c\mathit{.erase}(i)):=}\\
  & \multicolumn{2}{l}{\wedge\:{c'}_{size} := {c}_{size} - 1}\\
  & \wedge\: {c'}_k := &\!\!\!\!\textit{store}(c_k,{i'}_{pos}, \textit{select}(c_k, {i'}_{pos} + 1)),\\
  & & \:\:\:\:\:\:\ldots,\\
  & & \textit{store}(c_k, c_{size} - 2, \textit{select}(c_k, c_{size} - 1)))\\
  & \wedge\: {c'}_v := &\!\!\!\!\textit{store}(c_v,{i'}_{pos}, \textit{select}(c_v, {i'}_{pos} + 1)),\\
  & & \:\:\:\:\:\:\ldots,\\
  & & \textit{store}(c_v, c_{size} - 2, \textit{select}(c_v, c_{size} - 1)))\\
  & \multicolumn{2}{l}{\wedge\:{i'}_k := {c'}_k}\\
  & \multicolumn{2}{l}{\wedge\:{i'}_v := {c'}_v}\\
  & \multicolumn{2}{l}{\wedge\:{i'}_{pos} := {i}_{pos} + 1.}\\
\end{array}\]
%

Nota-se que tais modelos induzem implicitamente duas propriedades principais que possuem o objetivo de executar de forma correta as operações já mencionadas. A princípio a primeira propriedade se torna evidente quando $c_k$ e $c_v$ são considerados não vazios, isto é, $c_{size}$ também não é nulo para as operações de busca e exclusão de elementos. A segunda propriedade se torna evidente quando $i$ é considerado um \textit{iterator} do respectivo \textit{container} referido, isto é, dado um \textit{container} $c$ com os ponteiros bases $c_k$ e $c_v$, $i_k = c_k$ e $i_v = c_v$ são mantidos.% Na verdade, estas e outras propriedades específicas são tratadas em seus respectivos modelos operacionais conforme descrito no capítulo~\ref{chapter:smt-bmc}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Resumo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Neste capítulo, foi descrito o subconjunto denominado \textit{Qt Container} que está integrado ao módulo \textit{Qt Core} do \textit{framework} multiplataforma Qt, sendo classificado em dois subgrupos: sequenciais e associativos, dependendo da estrutura de armazenamento implementada, logo em seguida, é descrito a linguaguem base formalizada por Ramalho \textit{et al.}~\cite{ECBS13}, mas adaptada com o objetivo de formular adequadamente a verificação de ambos tipos de \textit{containers} existentes. Por fim, os \textit{containers} sequenciais e associativos foram descritos de forma detalhada, a fim de ressaltar todos os metódos que constituem essas bibliotecas assim como, a forma que estão implementados a partir de uma transformação SSA realizada. Como resultado, o conteúdo apresentado nesse capítulo fornece todo o embasamento necessário a cerca modelo operacional criado para \textit{Qt Container} usado em QtOM.


%Chama outro arquivo%
%\input{4_cpp/templates.tex}