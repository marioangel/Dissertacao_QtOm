%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Fundamentação Teórica}
\label{chapter:background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Este capítulo descreve a arquitetura de ESBMC++ e algumas características estruturais do \textit{framework} multiplataforma Qt. Este trabalho consiste na verificação de programas em C$++$ baseados no \textit{framework} Qt, usando a ferramenta ESBMC$++$, a qual possui um \textit{front-end} baseado em CBMC com o intuito de produzir VCs para um programa Qt/C$++$. No entanto, em vez de passar tais VCs para um solucionador SAT, o ESBMC$++$ os codifica por meio de diferentes teorias de base do SMT e em seguida, passa os resultados associados para um solucinador SMT.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ESBMC++}
\label{sec:arch}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

O ESBMC$++$ é um \textit{context-bounded model checker} baseado em solucionadores SMT para verificar programas ANSI-C/C$++$~\cite{ECBS13,TSE12,ICSE11,Morse2013}. A Figura~\ref{figure:Fig1} apresenta a arquitetura do ESBMC$++$. Em especial, o ESBMC$++$ verifica programas sequencias e multi-tarefas e analisa propriedades relacionadas à estouro aritméticow, divisão por zero, indíces de vetor fora do limite, segurança de ponteiros, bloqueio fatal e corrida de dados. No ESBMC$++$, o processo de verificação se encontra totalmente automático, isto é, todos os processos realizados são representados nas caixas cinzas de acordo com a Figura~\ref{figure:Fig1}, ou seja, não existe nenhuma possibilidade do usuário pré-processar programas em qualquer fase descrita~\cite{Morse2014,MorseHandling2013}.

\begin{figure}[htb]
  \centering
  \includegraphics[width=4in]{figuras/Fig1.pdf}
  \caption{Visão geral da arquitetura do ESBMC$++$.}
  \label{figure:Fig1}
\end{figure}

Durante o processo de verificação, primeiramente é realizado o \textit{parser} do código fonte a ser analisado. Na verdade, o \textit{parser} utilizado no ESBMC$++$ é fortemente baseado no compilador GNU C$++$~\cite{ECBS13}, uma vez que a abordagem permite que o ESBMC$++$ encontre a maioria dos erros de sintaxe já relatados pelo GCC. Programas ANSI-C/C$++$/Qt são convertidos em uma árvore de representação intermédiaria (do inglês, Intermediate Representation - IRep), e boa parte dessa representação criada é usada como base para os passos restantes da verificação. Vale ressaltar que o modelo operacional (MO) é o ponto chave neste processo de conversão, o que será explicado no Capítulo~\ref{chapter:smt-bmc}.

Na etapa seguinte, denominada \textit{type-checking}, verificações adicionais são realizadas, na árvore IRep, que incluem atribuições, \textit{type-cast}, inicialização de ponteiros e a análise das chamadas de função, assim como, a criação de templates e instanciações~\cite{ECBS13}. Em seguida, a árvore IRep é convertida em expressões \textit{goto} que simplificam a representação das instruções (por exemplo, a substituição de \textit{while} por \textit{if} e instruções \textit{goto}) e são executadas de forma simbólica por \textit{GOTO-symex}). Como resultado, uma atribuição estática única (do inglês, Single Static Assignment - SSA) é criada. Baseado nisso, o ESBMC++ cria duas fórmulas chamadas \textit{restrições} (ou seja, premissas e atribuições de variáveis) e \textit{propriedades} (ou seja, condições de segurança e premissas definidas pelo o usuário) consideradas funções recursivas. Essas fórmulas acumulam predicados de fluxo de controle de cada ponto do programa analisado e os usa para armazernar restrições (fórmula ${\cal C}$) e propriedades (fórmula ${\cal P}$), de modo que reflita adequadamente a semântica do programa. Posteriormente, essas duas fórmulas de lógica de primeira ordem são verificadas por um solucinador SMT.

Por fim, se uma violação em alguma propriedade for encontrada, um contraexemplo é gerado pelo ESBMC++~\cite{Cordeiro2012}, o qual atribui valores as variáveis de programa com o intuito de reproduzir o erro encontrado. De fato, contraexemplos possuem grande importância para o diagnóstico e a análise da execução do programa, dado que as violações encontradas pode ser sistematicamente rastreadas~\cite{RochaBCN12}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Satisfiability Modulo Theories (SMT)}
%\section{Teorias do Módulo da Satisfabilidade}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SMT determina a satisfatibilidade das fórmulas expressas em lógica de primeira ordem, usando uma combinação de suas teorias, a fim de generalizar a satisfabilidade proposicional, dando suporte à funções não interpretadas, aritmética linear e não linear, vetores de bit, tuplas, vetores e outras teorias de primeira ordem. Dado uma teoria ${\cal T}$ e uma fórmula livre de quantificadores $\psi$, a respectiva fórmula, é satisfatível ${\cal T}$ se somente se existir uma estrutura que satisfaça tanto a fórmula quanto as sentenças de ${\cal T}$, ou seja, se ${\cal T}\cup \{\psi\}$ é satisfatível~\cite{Bradley07}. Dado um conjunto $\Gamma\cup \{\psi\}$ das fórmulas sobre ${\cal T}$, $\psi$ é uma consequência ${\cal T}$ de $\Gamma$ ($\Gamma\models_{\cal T}\psi$) se e somente se todo os modelos de ${\cal T}\cup\Gamma$ é também um modelo de $\psi$. Desta forma, ao verificar $\Gamma\models_{\cal T}\psi$ pode se reduzi-la para verificação de um satisfatível $\cal T$ de $\Gamma\cup\{\neg\psi\}$.

As teorias dos vetores dos solucinadores SMT são normalmente baseadas em axiomas de McCarthy~\cite{McCarthy62}. A função \emph{select(a,i)} indica o valor de $a$ no índice $i$ e a função \emph{store(a,i,v)} indica um vetor que é exatamente o mesmo que $a$, a menos que o valor do índice $i$ seja $v$. Formalmente,\emph{select} e \emph{store} pode então ser caracterizados por axiomas~\cite{Z308,Boolector09,CVC07}

\[
\begin{array}{l}
 i=j  \Rightarrow select\left(store\left(a,i,v\right),j\right)=v \\
\end{array}
\]

{\noindent e}

\[
\begin{array}{l}
 i \neq j \Rightarrow select\left(store\left(a,i,v\right)=select\left(a,j\right).
\end{array}
\]

\noindent
Tuplas são utilizadas para modelar \textit{union} e \textit{struct} em ANSI-C, além de fornecer as operações de \textit{store} e \textit{select}, as quais são semelhantes as usadas em vetores. No entanto, elas trabalham com elementos de tupla, isto é, cada campo de uma tupla é representado por uma constante inteira. Desta forma, a expressão $\mathit{select}(t, f)$ indica o campo $f$ de uma tupla $t$, enquanto a expressão $\mathit{store}(t, f, v)$ indica uma tupla $t$ que, no campo $f$, tem o valor $v$. A fim de analisar a satisfabilidade de uma determinada fórmula, solucianadores SMT lidam com termos baseados em suas teorias usando um procedimento de decisão~\cite{MouraB09}.

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\section{O Framework Multiplataforma Qt}
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Diversos módulos de software, conhecidos como \textit{frameworks}, têm sido utilizados para acelerar o processo de desenvolvimento de aplicações. Diante desse contexto, o \textit{framework} multiplataforma Qt~\cite{Qt15} representa um bom exemplo de um conjunto de classes reutilizavéis, onde a engenharia de software presente é capaz de favorecer o desenvolvimento de aplicações gráficas que utilizam C++~\cite{Qt15} e Java~\cite{qtjambi}. São fornecidos programas que são executados em diferentes plataformas tanto de hardware quanto de software com o mínimo de mundaças nas aplicações desenvolvidas com o objetivo de manter o mesmo desempenho. Samsung~\cite{Samsung}, Philips~\cite{Philips} e Panasonic~\cite{Panasonic} são alguma das empresas presentes na lista top $10$ da Fortune $500$ que utilizam Qt para o desenvolvimento de suas aplicações~\cite{Qt15}.

De acordo com o relatório do \textit{Cross-Platform Tool Benchmarking} 2014~\cite{cross2014}, Qt é o \textit{framework} multiplataforma que lidera o desenvolvimento de aplicações para dispositivos e interfaces para usuários. Com as suas bibliotecas organizadas em módulos conforme mostrado na Figura~\ref{figure:Fig4}, o módulo \textit{QtCore}~\cite{Qt15} é considerado um módulo base de Qt, pois, contêm todas as classes não gráficas das classes \textit{core} e em particular contém um conjunto de bibliotecas denominado de classes \textit{Containers} que possui como implementação um modelo base para esses tipos de classe, com um intuito de uso geral ou como uma alternativa para \textit{containers} STL. Esses tipos de estruturas são amplamentes conhecidos e usados em aplicações reais com Qt e consistem em um item muito importante nos processos de verificação.

\begin{figure}[htb]
  \centering
  \includegraphics[width=2.0in]{figuras/Fig4.pdf}
  \caption{Visão geral da estrutura do \textit{framework} Qt.}
  \label{figure:Fig4}
\end{figure}

Além desses submódulos, o \textit{QtCore} também contêm um sistema de eventos denominado Qt \textit{Event}, onde, Qt representa um evento por meio de um objeto que herda a classe \textit{QEvent} (classe base para o sistema Qt \textit{Event}) na qual contêm informações necessárias sobre todas as ações (internas ou externas) relacionadas a uma dada aplicação. Uma vez instanciado, este objeto é enviado para uma instância da classe \textit{QObject}, o qual possui como função chamar um método escalonador apropriado para o seu tipo.

Desta forma, o \textit{framework} Qt fornece uma completa abstração para aplicações que envolvem interface gráfica com o usuário (do inglês, \textit{Graphical User Interface} - GUI) usando APIs nativas, a partir das diferentes plataformas operacionais disponivéis no mercado, para consultar as métricas e desenhar os elementos gráficos. Também são oferecidos \textit{signals} e \textit{slots} com o objetivo de realizar a comunicação entres os objetos criados~\cite{QtLibs5}. Outra característica importante a ser ressaltada deste \textit{framework} é a presença de um compilador denominado \textit{MetaObject}, o qual é responsável por interpretar os programas criados e gerar um código em C++ com meta informações~\cite{Moc}.

Por fim e de acordo com o apresentado, nota-se que a complexidade e robustez de programas que utilizam o \textit{framework} Qt afeta diretamente os processos de verificação relacionados a eles. Em resumo, o QtOM possui uma representação de todas as classes acima referidas e suas respectivas interações a fim de suportar também todo o sistema Qt \textit{Event}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Resumo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Neste capítulo, foi descrito a arquitetura de ESBMC$++$ sendo explicado o objetivo e a tarefa de cada etapa de seu processo de verificação de acordo como mostrado na figura~\ref{figure:Fig1}, descreveu-se também como as técnicas SMT são usadas para determinar a satisfatibilidade das fórmulas expressas em lógica de primeira ordem e por fim, foi descrito algumas características estruturais do \textit{framework} multiplataforma Qt.