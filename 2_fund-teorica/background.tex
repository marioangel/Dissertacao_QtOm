%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Fundamentação Teórica}
\label{chapter:background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Este capítulo descreve a arquitetura do ESBMC$++$ e algumas características estruturais do \textit{framework} multiplataforma Qt. Este trabalho consiste na verificação de programas escritos em C$++$ baseados no \textit{framework} multiplataforma Qt, usando a ferramenta ESBMC$++$, a qual possui um \textit{front-end} baseado no CBMC com o intuito de produzir VCs para um programa Qt/C$++$. No entanto, em vez de passar tais VCs para um solucionador SAT, o ESBMC$++$ os codifica por meio de diferentes teorias de base do SMT e em seguida, passa as fórmulas associadas para um solucinador SMT.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ESBMC++}
\label{sec:arch}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

O ESBMC$++$ é um \textit{context-bounded model checker} baseado em solucionadores SMT para verificar programas ANSI-C/C$++$~\cite{ECBS13,ICSE11,TSE12,Morse2013}. A Figura~\ref{figure:Fig1} apresenta a arquitetura do ESBMC$++$. Em especial, o ESBMC$++$ verifica programas sequencias e multi-tarefas e analisa propriedades relacionadas à estouro aritmético, divisão por zero, indíces de vetor fora do limite, segurança de ponteiros, bloqueio fatal e corrida de dados. No ESBMC$++$, o processo de verificação se encontra totalmente automático, isto é, todos os processos realizados são representados nas caixas cinzas de acordo com a Figura~\ref{figure:Fig1}~\cite{Morse2014,MorseHandling2013}.

\begin{figure}[htb]
  \centering
  \includegraphics[width=5in]{figuras/Fig1.pdf}
  \caption{Visão geral da arquitetura do ESBMC$++$.}
  \label{figure:Fig1}
\end{figure}

Durante o processo de verificação, primeiramente é realizado o \textit{parser} do código fonte a ser analisado. Na verdade, o \textit{parser} utilizado no ESBMC$++$ é fortemente baseado no compilador GNU C$++$~\cite{ECBS13}, uma vez que a abordagem permite que o ESBMC$++$ encontre a maioria dos erros de sintaxe já relatados pelo GCC. Programas ANSI-C/C$++$/Qt são convertidos em uma árvore de representação intermédiaria (do inglês, \textit{Intermediate Representation} - IRep), e boa parte dessa representação criada é usada como base para os passos restantes da verificação. Vale ressaltar que o modelo operacional (MO) é o ponto chave neste processo de conversão, o que será explicado no Capítulo~\ref{chapter:smt-bmc}.

Na etapa seguinte, denominada \textit{type-checking}, verificações adicionais são realizadas, na árvore IRep, que incluem atribuições, \textit{type-cast}, inicialização de ponteiros e a análise das chamadas de função, assim como, a criação de \textit{templates} e instanciações~\cite{ECBS13}. Em seguida, a árvore IRep é convertida em expressões \textit{goto} que simplificam a representação das instruções (por exemplo, a substituição de \textit{while} por \textit{if} e instruções \textit{goto}) e são executadas de forma simbólica pelo \textit{GOTO-symex}). Como resultado, uma atribuição estática única (do inglês, \textit{Single Static Assignment} - SSA) é criada. Baseado nisso, o ESBMC++ cria duas fórmulas chamadas \textit{restrições} (ou seja, premissas e atribuições de variáveis) e \textit{propriedades} (ou seja, condições de segurança e premissas definidas pelo o usuário) consideradas funções recursivas. Essas fórmulas acumulam predicados de fluxo de controle de cada ponto do programa analisado e os usa para armazernar restrições (fórmula $\mathcal{C}$) e propriedades (fórmula $\mathcal{P}$), de modo que reflita adequadamente a semântica do programa. Posteriormente, essas duas fórmulas de lógica de primeira ordem são verificadas por um solucinador SMT.

Por fim, se uma violação em alguma propriedade for encontrada, um contraexemplo é gerado pelo ESBMC++~\cite{Cordeiro2012}, o qual atribui valores às variáveis de programa com o intuito de reproduzir o erro encontrado. De fato, contraexemplos possuem grande importância para o diagnóstico e a análise da execução do programa, dado que as violações encontradas pode ser sistematicamente rastreadas~\cite{RochaBCN12}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Satisfiability Modulo Theories (SMT)}
%\section{Teorias do Módulo da Satisfabilidade}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SMT determina a satisfatibilidade das fórmulas expressas em lógica de primeira ordem, usando uma combinação de suas teorias, a fim de generalizar a satisfabilidade proposicional, dando suporte às funções não interpretadas, aritmética linear e não linear, vetores de bit, tuplas, \textit{arrays} e outras teorias de primeira ordem. Dado uma teoria $\mathcal{T}$ e uma fórmula livre de quantificadores $\psi$, a respectiva fórmula é satisfatível $\mathcal{T}$ se somente se existir uma estrutura que satisfaça tanto a fórmula quanto as sentenças de $\mathcal{T}$, ou seja, se $\mathcal{T}\cup \{\psi\}$ é satisfatível~\cite{Bradley07}. Dado um conjunto $\Gamma\cup \{\psi\}$ das fórmulas sobre $\mathcal{T}$, $\psi$ é uma consequência $\mathcal{T}$ de $\Gamma$ ($\Gamma\models_\mathcal{T}\psi$) se e somente se todo os modelos de $\mathcal{T}\cup\Gamma$ é também um modelo de $\psi$. Desta forma, ao verificar $\Gamma\models_\mathcal{T}\psi$ pode se reduzi-la para verificação de um satisfatível $\mathcal{T}$ de $\Gamma\cup\{\neg\psi\}$.

A partir do contexto descrito, as teorias de \textit{arrays} dos solucionadores SMT são normalmente baseadas em axiomas de McCarthy~\cite{McCarthy62}. A função \emph{select(a,i)} indica o valor de $a$ no índice $i$ e a função \emph{store(a,i,v)} indica um vetor que é exatamente o mesmo que $a$, a menos que o valor do índice $i$ seja $v$. Formalmente, \emph{select} e \emph{store} pode então ser caracterizados por axiomas~\cite{Z308,Boolector09,CVC07}

\[
\begin{array}{l}
 i=j  \Rightarrow select\left(store\left(a,i,v\right),j\right)=v \\
\end{array}
\]

{\noindent e}

\[
\begin{array}{l}
 i \neq j \Rightarrow select\left(store\left(a,i,v\right)=select\left(a,j\right).
\end{array}
\]

\noindent
Tuplas são utilizadas para modelar \textit{union} e \textit{struct} em ANSI-C, além de fornecer as operações de \textit{store} e \textit{select}, as quais são semelhantes as usadas em vetores. No entanto, elas trabalham com elementos de tupla, isto é, cada campo de uma tupla é representado por uma constante inteira. Desta forma, a expressão $\mathit{select}(t, f)$ indica o campo $f$ de uma tupla $t$, enquanto a expressão $\mathit{store}(t, f, v)$ indica uma tupla $t$ que, no campo $f$, tem o valor $v$. A fim de analisar a satisfabilidade de uma determinada fórmula, solucionadores SMT lidam com termos baseados em suas teorias usando um procedimento de decisão~\cite{MouraB09}.

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\section{O \textit{Framework} Multiplataforma Qt}
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Diversos módulos de software, conhecidos como \textit{frameworks}, têm sido utilizados para acelerar o processo de desenvolvimento de aplicações. Diante desse contexto, o \textit{framework} multiplataforma Qt~\cite{Qt15} representa um bom exemplo de um conjunto de classes reutilizavéis, onde a engenharia de software presente é capaz de favorecer o desenvolvimento de aplicações gráficas que utilizam C++~\cite{Qt15} e Java~\cite{qtjambi}. São fornecidos programas que são executados em diferentes plataformas tanto de hardware quanto de software com o mínimo de mundaças nas aplicações desenvolvidas com o objetivo de manter o mesmo desempenho. Samsung~\cite{Samsung}, Philips~\cite{Philips} e Panasonic~\cite{Panasonic} são algumas das empresas presentes na lista top $10$ da Fortune $500$ que utilizam Qt para o desenvolvimento de suas aplicações~\cite{Qt15}.

De acordo com o relatório do \textit{Cross-Platform Tool Benchmarking} 2014~\cite{cross2014}, Qt é o \textit{framework} multiplataforma que lidera o desenvolvimento de aplicações para dispositivos e interfaces para usuários. Com as suas bibliotecas organizadas em módulos, conforme mostrado na Figura~\ref{figure:Fig4}, o módulo \textit{QtCore}~\cite{Qt15} é considerado um módulo base de Qt pois, contém todas as classes não gráficas das classes \textit{core} e em particular contém um conjunto de bibliotecas denominado de classes \textit{Containers} que possui como implementação um modelo base para esses tipos de classe, com um intuito de uso geral ou como uma alternativa para \textit{containers} STL. Esses tipos de estruturas são amplamentes conhecidos e usados em aplicações reais com Qt e consistem em um item muito importante nos processos de verificação.

\begin{figure}[htb]
  \centering
  \includegraphics[width=2.5in]{figuras/Fig4.pdf}
  \caption{Visão geral da estrutura do \textit{framework} multiplataforma Qt.}
  \label{figure:Fig4}
\end{figure}

Além desses submódulos, o \textit{QtCore} também contêm um sistema de eventos denominado Qt \textit{Event}, onde, Qt representa um evento por meio de um objeto que herda a classe \textit{QEvent} (classe base para o sistema Qt \textit{Event}) na qual contêm informações necessárias sobre todas as ações (internas ou externas) relacionadas a uma dada aplicação. Uma vez instanciado, este objeto é enviado para uma instância da classe \textit{QObject}, o qual possui como função chamar um método escalonador apropriado para o seu tipo.

Desta forma, o \textit{framework} multiplataforma Qt fornece uma completa abstração para aplicações que envolvem interface gráfica com o usuário (do inglês, \textit{Graphical User Interface} - GUI) usando APIs nativas, a partir das diferentes plataformas operacionais disponivéis no mercado, para consultar as métricas e desenhar os elementos gráficos. Também são oferecidos \textit{signals} e \textit{slots} com o objetivo de realizar a comunicação entres os objetos criados~\cite{QtLibs5}. Outra característica importante a ser ressaltada deste \textit{framework} é a presença de um compilador denominado \textit{MetaObject}, o qual é responsável por interpretar os programas criados e gerar um código em C++ com meta informações~\cite{Moc}.

Por fim e de acordo com o apresentado, nota-se que a complexidade e robustez de programas que utilizam o \textit{framework} multiplataforma Qt afeta diretamente os processos de verificação relacionados a eles. Em resumo, o QtOM possui uma representação de todas as classes acima referidas e suas respectivas interações a fim de suportar também todo o sistema Qt \textit{Event}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Resumo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Neste capítulo, foi descrito a arquitetura de ESBMC$++$ sendo explicado o objetivo e a tarefa de cada etapa de seu processo de verificação de acordo com a Figura~\ref{figure:Fig1}, descreveu-se também como as técnicas SMT são usadas para determinar a satisfatibilidade das fórmulas expressas em lógica de primeira ordem e por fim, foi descrito algumas características estruturais do \textit{framework} multiplataforma Qt que de acordo com a Figura~\ref{figure:Fig4}, mostra as suas bibliotecas organizadas em módulos a qual, destaca-se o módulo \textit{QtCore}~\cite{Qt15} como um módulo base onde, estão as classes não gráficas e contém um conjunto de bibliotecas denominado de classes \textit{Containers}. Essas estruturas são amplamentes conhecidas e usadas em aplicações reais com Qt e consistem em um item muito importante nos processos de verificação. O módulo \textit{QtGui} também é descrito pois, fornece uma completa abstração para aplicações que envolvem interface gráfica usando APIs nativas, outra característica importante a ser ressaltada é a presença do compilador chamado \textit{MetaObject}~\cite{Moc}. Como resultado, o conteúdo apresentado nesse capítulo fornece todo o embasamento necessário para compreensão da ferramenta, técnica SMT e o \textit{framework} utilizado neste trabalho.