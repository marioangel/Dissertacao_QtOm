%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Método proposto}
\label{chapter:smt-bmc}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Este capítulo descreve todo o processo de verificação de ESBMC$++$ junto com QtOM, cujo torna possível a verificação de aplicações escritas em C$++$ que utilizam o \textit{framework} Qt, e o processo de criação de QtOM, enfatizando as classes \textit{containers} do \textit{framework} Qt. Inicialmente, na Seção~\ref{sec:introdutions} é descrito como QtOM auxilia ESBMC$++$ a transformar o código de entrada em uma árvore IRep e a identificar cada estrutura presente na aplicação e como está disposto as classes containers no \textit{framework} Qt, assim como, o seu uso em aplicações. Logo em seguida, nas Seções~\ref{sec:preconditions} e~\ref{sec:postconditions} é descrito como QtOM se utiliza de pré e pós-condições para se obter um comportamento igual ao descrito na documentação do \textit{framework} Qt~\cite{Qt15}. Na Seção~\ref{sec:language} é descrito a linguagem que foi utilizada como base para se criar as representações contidas em QtOM com o objetivo de formalizar a implementação de cada \textit{container}. Por fim, nas Seções~\ref{sec:sequential} e~\ref{sec:associative} é descrito como as classes containers foram divididas entre sequenciais e associativas, e o seu comportam no momento de sua utilização por QtOM através de lógica formal.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introdução}
\label{sec:introdutions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Inicialmente, o \textit{parser} utilizado já havia sido mencionado na Seção~\ref{sec:arch} do Capítulo~\ref{chapter:background} e, nesta etapa, é onde o ESBMC$++$ transforma o código de entrada em uma árvore IRep que contém todas as informações necessárias para o seu processo de verificação. Sendo assim, ao fim desta etapa, ESBMC$++$ deve identifica corretamente cada estrutura presente na aplicação analisada. No entanto, ESBMC$++$ apenas suporta a verificação de aplicações ANSI-C/C$++$. Porém, apesar das aplicações utilizarem C$++$ o \textit{framework} Qt possui suas bibliotecas nativas, as quais possuem estruturas hierárquicas próprias que inviabilizam a utilização da ferramenta. Como consequência, o processo de verificação para essas bibliotecas e suas respectivas implementações otimizadas afetariam de maneira desnecessária as VCs, além do mais poderiam não conter qualquer afirmação a respeito de propriedades específicas do \textit{framework}, tornando a verificação uma tarefa inviável.

O uso do QtOM neste capítulo possui como objetivo solucionar o problema descrito acima, por ser uma representação simplificada que considera a estrutura de cada biblioteca e suas respectivas classes associadas, incluindo atributos, assinaturas de métodos, protótipos de funções e assertivas que garantem que cada propriedade seja formalmente verificada. Na verdade, existem muitas propriedades a serem verificadas como acesso de memória inválida, valores negativos que representam períodos de tempo, acesso a arquivos inexistentes e ponteiros nulos. Além disso, existem pré e pós-condições que são necessárias para executar corretamente os métodos do Qt. Vale ressaltar que QtOM é ligado de forma manual ao ESBMC$++$, logo no início do processo de verificação, como mostrado na Figura~\ref{figure:Fig2}. 

Desta forma, o QtOM pode auxiliar o processo de \textit{parser} para criar uma representação intermediária em C$++$ que de acordo com a documentação do \textit{framework} analisado, possui todas as assertivas indispensáveis para a verificação das propriedades mencionadas acima. A documentação do \textit{framework} Qt é utilizada para facilitar a identificação de propriedades ou na extração de estruturas pertinentes ao \textit{framework}. Por fim, o fluxo de verificação segue de maneira tradicional. 

\begin{figure}[htb]
  \centering
  \includegraphics[width=5.5in]{figuras/Fig2.pdf}
  \caption{Conectando QtOM a ESBMC$++$.}
  \label{figure:Fig2}
\end{figure}


O módulo \textit{Qt Core} possui um subconjunto de classes denominado \textit{Qt Container}~\cite{Qt15} como alternativa para os \textit{containers} da \textit{Standard Template Library} (STL) disponíveis na linguagem C++~\cite{Iso2003}. Por exemplo, durante o desenvolvimento de uma determinada aplicação, é necessário a criação de uma pilha de tamanho variável para o armazenamento de objetos do tipo \textit{QWidgets}, neste caso, uma alternativa seria o uso da classe \textit{QStack} que implementa um \textit{container} com a política LIFO (do inglês, \textit{last-in, first-out}) (\textit{e.g.}, \textit{QStack}$<$\textit{QWidget}$>$). Além disso, tais \textit{containers} também fazem uso de estruturas denominadas \textit{iterators} no estilo Java/STL, de modo a se deslocar ao longo dos dados armazenados no \textit{container} criado.  

Desta forma, esse subconjunto de classes pode ser classificado em dois subgrupos: sequenciais e associativos, dependendo da estrutura de armazenamento implementada. Neste contexto, as classes \textit{QList}, \textit{QLinkedList}, \textit{QVector}, \textit{QStack} e \textit{QQueue} são classificadas como \textit{containers} sequenciais, enquanto as classes \textit{QMap}, \textit{QMultiMap}, \textit{QHash}, \textit{QMultiHash} e \textit{QSet} são classificadas como \textit{containers} associativos.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Pré-condições}
\label{sec:preconditions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ao se utilizar modelos limitados é possível diminuir a complexidade que é associada as árvores IRep. Desta forma, o ESBMC$++$ é capaz de construir árvores IRep de uma forma muito rápida, com baixa complexidade, mas que englobam todas as propriedades necessárias para a verificação dos programas desejados. Além disso, o uso de assertivas se torna indispensável para verificar propriedades relacionadas aos métodos do \textit{framework} multiplataforma Qt, assim como, as suas respectivas execuções que não são contempladas pelas bibliotecas padrões. Deste modo, tais assertivas são integrados aos respectivos métodos com o objetivo de detectar violações em relação ao uso incorreto do framework Qt. 

Em resumo, baseado na adição de assertivas, ESBMC$++$ é capaz de verificar propriedades específicas contidas em QtOM e identificar como pré-condições partes das propriedades relacionadas, ou seja, as propriedades que devem ser mantidas de forma que haja uma execução correta de um determinado método ou função. Por exemplo, a abordagem proposta pode verificar se um parâmetro, que representa uma determinada posição dentro de uma vetor é maior ou igual a zero.

De acordo com o fragmento de código mostrado na Figura~\ref{fig:Fig3} que pertence a aplicação chamada \textit{GeoMessage Simulator}. Esta aplicação fornece mensagens para componentes do sistema na plataforma ArcGIS~\cite{geomessage}. Como mostrado, o método $setFileName$() manipula uma pré-condição (veja linha $6$), onde $m\_inputFile$ é um objeto da classe \textit{QFile} que proporciona uma interface de leitura e escrita para se manipular arquivos~\cite{Qt15}. Ao ser definido um nome ao arquivo, o objeto $fileName$ da \textit{QString} não pode ser nulo. Desta forma, quando $setFileName$() é chamado, o ESBMC$++$ interpreta o seu comportamento de acordo com o implementado em QtOM como mostrado na Figura~\ref{fig:Fig4}.

\begin{figure}[htb]
\centering
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}
QString loadSimulationFile( const QString &fileName )
{
   if(m_inputFile.isOpen())
     m_inputFile.close();
     
   m_inputFile.setFileName(fileName);
   
   //Check file for at least one message
   if( !doInitialRead() ) 
   {
      return QString(m_inputFile.fileName() + "is an empty message file");
   }
   else
   {
      return NULL;
   }
}
\end{lstlisting}
\end{minipage}
\caption{Fragmento de código da função \textit{loadSimulationFile} presente no benchmark Geomessage Simulator.}
\label{fig:Fig3}
\end{figure}

A Figura~\ref{fig:Fig4} mostra um trecho do modelo operacional correspondente à classe QFile com uma implementação de $setFileName$() (veja as linhas 5-10), onde apenas as pré-condições são verificadas.

\begin{figure}[htb]
\centering
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}
class QFile {
...
    QFile( const QString &name ) { ... }
    ...
    void setFileName( const QString &name ){
       __ESBMC_assert( !name.isEmpty(), "The string must not be empty" );
       __ESBMC_assert( !this->isOpen(), "The file must be closed" );
    }
    ...
};
\end{lstlisting}
\end{minipage}
\caption{Modelo operacional de $setFileName$() presente na classe QFile.}
\label{fig:Fig4}
\end{figure}

Em particular, se o objeto QString passado como um parâmetro não estiver vazio (veja a linha 6), a operação é válida e, consequentemente, a assertiva é considerada \textit{true}. Caso contrário, se uma operação incorreta for realizada, como uma \textit{string} vazia for passada como parâmetro, a assertiva é considerada \textit{false}. Nesse caso, o ESBMC$++$ retornaria um contraexemplo com todos os passos necessários para reproduzir a execução de tal violação, além de descrever o erro da respectiva premissa violada.

Do ponto de vista da verificação de software, existem métodos/funções que também não apresentam qualquer propriedade a ser verificada como aqueles cuja única finalidade é imprimir valores na tela. Dado que ESBMC$++$ realiza o processo verificação a nível de software ao invés de testar o hardware, a corretude a cerca do valor impresso na tela não foi abordado neste trabalho. Por fim, para tais métodos só existem assinaturas, de modo que o verificador proposto seja capaz de reconhecer a estrutura desejada para que durante o processo de análise seja construído uma árvores IRep confiável. No entanto, eles não apresentam qualquer modelagem (corpo de função), uma vez que não exista nenhuma propriedade a nível de software a ser verificada.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Pós-condições}
\label{sec:postconditions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Em aplicações reais existem métodos que não contêm apenas propriedades que serão tratadas como pré-condição, mas também serão considerados como pós-condições~\cite{monteiro2015,Musuvathi2002}. Por exemplo, de acordo com a documentação do \textit{framework} Qt~\cite{Qt15}, a função $setFileName$ conforme descrita na Seção~\ref{sec:preconditions} não deve ser utilizada se o respectivo arquivo passado como parâmetro já estiver sendo utilizado, o que é verificado em seu código fonte a partir da estrutura $if$ presente nas linhas $3$ e $4$ visto na Figura~\ref{fig:Fig3}.

No entanto, a execução da instrução presente na linha $4$ (veja Fig.~\ref{fig:Fig3}) seria não determinística para o ESBMC$++$, assim como a assertiva presente na linha $7$ (veja Fig.~\ref{fig:Fig4}) do modelo operacional associado, uma vez que não há como se afirmar se o respectivo arquivo está sendo utilizado ou não. Desta forma, é evidente que será necessário simular o comportamento do método $isOpen$() com o intuito de verificar de forma coerente as propriedades relacionadas com manipulação de arquivos. Como a classe \textit{QFile} indiretamente herda, a partir da classe \textit{QIODevice}, os métodos $open$() e $isOpen$(), se cria um modelo operacional para QIODevice conforme mostrado na Figura~\ref{fig:Fig5} a partir do descrito na documentação do \textit{framework} com suas representações e simulações comportamentais.

\begin{figure}[htb]
\centering
\begin{minipage}{0.6\textwidth}
\begin{lstlisting}
class QIODevice {
    ...
    bool QIODevice::open(OpenMode mode){
       this->__openMode = mode;
       if (this->__openMode == NotOpen)
           this->__isOpen = false;
       this->__isOpen = true;
    }
    
    bool isOpen() const{
       return this->__isOpen;
    }
    ...
private:
    bool __isOpen;
    OpenMode __openMode;
    ...
};
\end{lstlisting}
\end{minipage}
\caption{Modelo operacional para os métodos $open$() e $isOpen$() na classe \textit{QIODevice}.}
\label{fig:Fig5}
\end{figure}

A Figura~\ref{figure:figMO} demonstra como foi criado o modelo operacional para a classe \textit{QIODevice} descrito acima em QtOM a partir da documentação do \textit{framework} Qt.

\begin{figure}[htb]
  \centering
  \includegraphics[width=6.5in]{figuras/figMO.png}
  \caption{Modelo operacional para os métodos $open$() e $isOpen$() na classe \textit{QIODevice}.}
  \label{figure:figMO}
\end{figure}

Por fim, todos os métodos que resultam em uma condição que deve ser mantida, a fim de permitir uma adequada execução de futuras instruções, devem apresentar uma simulação do seu comportamento. Consequentemente, um determinado modelo operacional deve seguir de forma rigorosa as especificações descritas na documentação oficial do \textit{framework}~\cite{Qt15} com o objetivo de se obter o mesmo comportamento, assim como, incluir mecanismos necessários a verificação do código. Como resultado, é necessário verificar o nível de equivalência entre o modelo operacional e a biblioteca original, com o intuito de se comparar o comportamento de ambos, tendo em vista que os modelos operacionais desenvolvidos são uma cópia simplificada das bibliotecas originais com todos os mecanismos necessários para a verificação do código~\cite{pereira2016}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linguagem Base}
\label{sec:language}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Com o intuito de implementar o modelo operacional para as classes que compõe o \textit{Qt Container}, a formalização da linguagem base descrita por Ramalho \textit{et al.}~\cite{ECBS13} é utilizada e se estende até a formulação das propriedades $\mathcal{C}$ e $\mathcal{P}$. Contudo, tal linguagem foi adaptada, neste trabalho, com o objetivo de formular adequadamente a verificação de ambos tipos de \textit{containers} (\textit{i.e.}, sequencial ou associativo) como mostrado na Figura~\ref{ccl-fig}. 

De acordo com a Figura~\ref{ccl-fig}, os elementos básicos estão divididos em dois domínios sintáticos: $\mathit{V}$ para valores e $\mathit{K}$ para as chaves.   

\begin{figure}[htb]
\[\begin{array}{r@{\:\:}r@{\:\:}l}
  V  & ::= &
    v \:|\: \mathit{I_v} \:|\: \mathit{P_v}
\\[0.5ex]
  K  & ::= &
    k \:|\: \mathit{I_k} \:|\: \mathit{P_k}
\\[0.5ex]
   \mathit{I} & ::= &
     i \:|\: \mathit{C.begin()} \:|\: \mathit{C.end()}
\\  & | &
     \mathit{C.insert(\mathit{I}, \mathit{V}, \mathbb{N})} \:|\: \mathit{C.erase(\mathit{I})} \:|\: \mathit{C.search(\mathit{V})}
\\  & | &
     \mathit{C.insert(\mathit{K}, \mathit{V})} \:|\: \mathit{C.search(\mathit{K})}
\\[0.5ex]
   P  & ::= &
     p \:|\: P (+ \:|\: - ) P
       \:|\: \mathit{C_k} \:|\: \mathit{C_v} \:|\: \mathit{I_k} \:|\: \mathit{I_v}
\\[0.5ex]
   C  & ::= &
     c 
\\[0.5ex]
  \mathbb{N}  & ::= &
     n \:|\: \mathbb{N} (+ \:|\: * | \ldots) \mathbb{N}
       \:|\: \mathit{I_{pos}}
       \:|\: \mathit{C_{size}}
  \end{array}
\]
  \caption{Sintaxe da linguagem adaptada, base para a descrição formal dos \textit{containers}.}
  \label{ccl-fig}
\end{figure}

No entanto, os demais domínios, $\mathit{I}$, $\mathit{P}$, $\mathbb{N}$ e $\mathit{C}$ são mantidos por \textit{iterators}, ponteiros, índices inteiros e expressões \textit{container} adequadas, respectivamente. Assim, as variáveis $\mathit{k}$ do tipo $\mathit{K}$ e $\mathit{v}$ do tipo $\mathit{V}$ são adicionadas. Dessa forma, a notação $\mathit{I_v}$ representa um valor armazenado em um \textit{container} em uma posição direcionada pelo \textit{iterator} $\mathit{I}$ e $\mathit{I_k}$ representa uma chave armazenada em um \textit{container} em uma posição direcionada também pelo \textit{iterator} $\mathit{I}$. Tais notações são abreviações para $\mathit{store(i,I_{pos},I_v)}$ e $\mathit{store(i,I_{pos},I_k)}$, respectivamente, onde a expressão $\mathit{store}(t, f, v)$ indica \textit{container} $t$ que no campo $f$ possui um valor $v$. Da forma similar, $\mathit{P_k}$ e $\mathit{P_v}$ representam ponteiros para a chave e o valor, respectivamente.

Além disso, três outros métodos foram incluídos com o objetivo de descrever as operações realizadas em cada \textit{container}. O método $\mathit{C.insert(k, v)}$ insere um valor $\mathit{v}$ no \textit{container} $C$ com uma chave correspondente $\mathit{k}$ e possui como retorno um \textit{iterator} que aponta para o novo elemento inserido. O método $\mathit{C.search(k)}$ retorna um \textit{iterator} que aponta para a primeira evidência de um elemento com uma chave $\mathit{k}$ correspondente. De modo semelhante, $\mathit{C.search(v)}$ também retorna um \textit{iterator} que aponta para a primeira evidência de um elemento com um valor $\mathit{v}$ correspondente. No entanto, caso não exista nenhuma chave ou valor correspondente durante a operação com tais métodos, os mesmos retornarão $\mathit{C.end()}$, o qual corresponde ao \textit{iterator} que aponta para a posição imediatamente posterior ao último elemento. Por fim, $\mathit{C_k}$ é um endereço de memória que armazena o início das chaves dos \textit{containers}, assim como, $\mathit{C_v}$ é usado para armazenar os valores dos \textit{containers}.

É importante ressaltar que, todas demais operações provenientes da linguagem base mencionada são utilizadas aqui de acordo como descrito por Ramalho \textit{et al.}~\cite{ECBS13}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\textit{Containers} Sequenciais}
\label{sec:sequential}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textit{Containers} sequenciais tem como objetivo armazenar elementos em uma determinada ordem~\cite{Deitel}. De acordo com a documentação do Qt~\cite{Qt15}, \textit{QList} é a classe \textit{container} mais utilizada e possui uma estrutura em formato de lista encadeada. Da mesma forma, \textit{QLinkedList} também possui um estrutura em forma de lista, embora seja acessada através de \textit{iterators} ao invés de índices inteiros. Na classe \textit{QVector}, há presente uma estrutura de \textit{array} expansível e, por fim, \textit{QStack} e \textit{QQueue} fornecem estruturas que implementam diretivas como LIFO e FIFO (em inglês, \textit{first-in, first-out}), respectivamente.

Para simular adequadamente os \textit{containers} sequenciais, os modelos propostos utilizam da linguagem base descrita na Seção~\ref{sec:language}. Os \textit{containers} sequenciais são implementados a partir de um ponteiro $\mathit{C_v}$ para os valores do \textit{container} e também com um $\mathit{C_{size}}$, o qual é utilizado para representar o tamanho do respectivo \textit{container} (onde $\mathit{C_{size}} \in \mathbb{N}$). Dessa forma, os \textit{iterators} são modelados por meio de duas variáveis, uma do tipo $\mathbb{N}$ que é denominada de $\mathit{i_{pos}}$ e contém o valor do índice apontado por um \textit{iterator} e outra do tipo $P$ que é chamado por $\mathit{I_v}$ e aponta para um \textit{container} subjacente.

Vale ressaltar que todos os métodos, a partir dessas bibliotecas, podem ser expressos em variações simplificadas de três operações principais, \textit{insertion}($\mathit{C.insert(\mathit{I}, \mathit{V}, \mathbb{N})}$), \textit{deletion}($\mathit{C.erase(\mathit{I})}$) e \textit{\textit{search}}($\mathit{C.search(\mathit{V})}$). A partir da transformação SSA, os efeitos adversos sobre \textit{iterators} e \textit{containers} são explícitos para que as operações retornem novos \textit{iterators} e \textit{containers}.

Por exemplo, um \textit{container} $c$ com uma chamada \textit{c.search}($v$) representa uma pesquisa pelo elemento $v$ no respectivo \textit{container}. Deste modo, se esse elemento for encontrado, é retornado um \textit{iterator} que aponta para o respectivo elemento, caso contrário, é retornado um \textit{iterator} que aponta para a posição imediatamente posterior ao último elemento do \textit{container} (\textit{i.e.}, $\mathit{c.end()}$). Desta forma, a instrução ``$\mathit{c.search}(v);$'' torna-se ``$(c',i')=\mathit{c.search}(v);$'' que possuem efeitos adversos de forma explícita. Assim, a função de tradução $\mathcal{C}$ descreve premissas que estão relacionadas com o ``antes" e o ``depois" das respectivas versões das variáveis do modelo. Na verdade, notações com apóstrofe (\textit{e.g.}, $c'$ and $i'$) representam o estado das variáveis do modelo, após realizar a execução da respectiva operação; notações simplificadas (\textit{e.g.}, $c$ and $i$) representam os estados anteriores. Além disso, $select(c, i = lower_{bound} \ldots i = upper_{bound})$ representa uma expressão de \textit{loop} (\textit{e.g.}, $for$ e $while$), onde cada valor de $c$, a partir da posição $lower_{bound}$ até $upper_{bound}$, será selecionado. Da mesma forma, $store(c_{1}, lower_{bound}^{1},select(c_{2},$\\$lower_{bound}^{2})) \ldots store(c_{1},upper_{bound}^{1},select(c_{2},upper_{bound}^{2}))$ também representa uma expressão de \textit{loop}, onde cada valor de $c_{2}$, a partir de posição $lower_{bound}^{2}$ até a posição $upper_{bound}^{2}$ serão armazenados em $c_{1}$ nas posições $lower_{bound}^{1}$ até $upper_{bound}^{1}$, respectivamente. Sendo assim,
%
\[\begin{array}{lll}
\multicolumn{3}{l}{{\mathcal{C}}((c',i')=c\mathit{.search}(v)):=}\\
  & \multicolumn{2}{l}{\wedge\:i' := c.\textit{begin}()}\\
  & \wedge\: g_0 := &\!\!\!\!\textit{select}(c_v, i_{pos} = 0 \ldots i_{pos} = c_{size} - 1) == v \\
%  & & \textit{select}(\ldots(\textit{select}(c_v, i_{pos} = 0),\\
%  & & \:\:\:\:\:\:\ldots,\\
%  & & i_{pos} = c_{size} - 1))) == v \\
  & \multicolumn{2}{l}{\wedge\:{i'}_{pos} := \textit{ite}(g_0, i_{pos}, c_{size})}\\
  & \multicolumn{2}{l}{\wedge\:{i'}_v := {c'}_v.}\\
\end{array}\]

Com relação aos \textit{containers} sequenciais, os métodos $\mathit{C.insert(\mathit{I}, \mathit{V}, \mathbb{N})}$ e $\mathit{C.erase(\mathit{I})}$ se comportam como descrito por Ramalho \textit{et al.}~\cite{ECBS13}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\textit{Containers} Associativos}
\label{sec:associative}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

O grupo dos \textit{containers} associativos possui cinco classes: \textit{QMap}, \textit{QMultimap}, \textit{QHash}, \textit{QMultiHash} e \textit{QSet}. \textit{QMap} tem como abordagem um vetor associativo que conecta cada umas das chaves, de um certo tipo $K$, a um valor de um certo tipo $V$, onde as chaves associadas são armazenadas em ordem. Por um lado, \textit{QHash} apresenta um comportamento similar ao \textit{QMap}, contudo os dados armazenados possuem uma ordem arbitrária. \textit{QMultiMap} e \textit{QMultihash} representam respectivamente subclasses de \textit{QMap} e \textit{QHash}, no entanto, ambas classes permitem o armazenamento de valores replicados. Por fim, \textit{QSet} armazena objetos que estão associados a um conjunto de valores ordenados.

Com o intuito de implementar \textit{containers} associativos, um ponteiro $c_v$ é definido para os valores armazenados, um ponteiro $c_k$ é utilizado para armazenar as chaves do respectivo \textit{container} e uma variável $c_{size}$ é utilizada para guardar a quantidade de elementos inseridos. Em especial, $c_k$ e $c_v$ estão conectados por meio de um índice, ou seja, dado um \textit{container} $c$ que contém uma chave $k$ e um valor $v$ assume-se que

\[\begin{array}{r@{\:\:}c@{\:\:}l}
\left[\forall \omega \in \mathbb{N} | 0 \leq \omega < c_{size}\right]
\end{array}
\]

\noindent e

\[\begin{array}{r@{\:\:}c@{\:\:}l}
k \rightarrow v \iff select\left(c_k,\omega\right) = k \wedge select\left(c_v,\omega\right) = v,
\end{array}
\]

\noindent onde $(k \rightarrow v)$ indica que uma chave $k$ é associada a um valor $v$ and $\omega$ representa uma posição válida em $c_k$ e $c_v$. Além disso, a função \emph{select(a, i)} indica o valor de $a$ em um índice $i$~\cite{ECBS13}. Novamente, todas as operações dessas bibliotecas podem ser expressadas a partir de uma variação simplificada das três principais operações citadas na Seção~\ref{sec:sequential}.

Portanto, a operação de inserção para \textit{containers} associativos pode ser realizada de duas maneiras diferentes. Em primeiro lugar, se a ordem não importa, um novo elemento é inserido no final de $c_k$ e $c_v$. Desta forma, dado um container $c$, o método $c.insert(k,v)$ ao ser chamado realiza inserções de elementos no \textit{container} $c$ com um o valor $v$ e associado a uma chave $k$, porém se $k$ já existe, ele substitui o valor associado a $k$ por $v$ e retorna um \textit{iterator} que aponta para o elemento inserido ou modificado. Deste modo,
%
\[\begin{array}{lll}
\multicolumn{3}{l}{{\mathcal{C}}((c',i')=c\mathit{.insert}(k,v)):=}\\
  & \multicolumn{2}{l}{\wedge\:{c'}_{size} := {c}_{size} + 1}\\
  & \multicolumn{2}{l}{\wedge\:i' := c.\textit{begin}()}\\
  & \wedge\: g_0 := &\!\!\!\!\textit{select}(c_k, i_{pos} = 0 \ldots i_{pos} = c_{size} - 1) == k \\
  %& \wedge\: g_0 := &\!\!\!\!(\textit{select}(\ldots(\textit{select}(\\
  %& & \textit{select}(\ldots(\textit{select}(c_k, i_{pos} = 0),\\
  %& & \:\:\:\:\:\:\ldots,\\
  %& & i_{pos} = c_{size} - 1))) = k \\
  & \multicolumn{2}{l}{\wedge\:{i'}_{pos} := \textit{ite}(g_0, i_{pos}, c_{size})}\\
  & \wedge\: {c'}_k := &\!\!\!\!\textit{store}(c_k,{i'}_{pos} + 1, \textit{select}(c_k, {i'}_{pos})),\\
  & & \:\:\:\:\:\:\ldots,\\
  & & \textit{store}(c_k, c_{size}, \textit{select}(c_k, c_{size} - 1)))\\
  %& \wedge\: {c'}_k := &\!\!\!\!\textit{store}(\ldots(\textit{store}(c_k\\
  %& & {i'}_{pos} + 1, \textit{select}(c_k, {i'}_{pos})),\\
  %& & \:\:\:\:\:\:\ldots,\\
  %& & c_{size}, \textit{select}(c_k, c_{size} - 1)))\\
  & \wedge\: {c'}_v := &\!\!\!\!\textit{store}(c_v,{i'}_{pos} + 1, \textit{select}(c_v, {i'}_{pos})),\\
  & & \:\:\:\:\:\:\ldots,\\
  & & \textit{store}(c_v, c_{size}, \textit{select}(c_v, c_{size} - 1)))\\
  %& \wedge\: {c'}_v := &\!\!\!\!\textit{store}(\ldots(\textit{store}(c_v\\
  %& & {i'}_{pos} + 1, \textit{select}(c_v, {i'}_{pos})),\\
  %& & \:\:\:\:\:\:\ldots,\\
  %& & c_{size}, \textit{select}(c_v, c_{size} - 1)))\\
  & \multicolumn{2}{l}{\wedge\:{c'}_k := \textit{store}(c_k, {i'}_{pos}, k)}\\
  & \multicolumn{2}{l}{\wedge\:{c'}_v := \textit{store}(c_v, {i'}_{pos}, v)}\\
  & \multicolumn{2}{l}{\wedge\:{i'}_k := {c'}_k}\\
  & \multicolumn{2}{l}{\wedge\:{i'}_v := {c'}_v.}\\
\end{array}\]
%

Em uma outra versão do método de inserção onde a ordem das chaves possuem importância. Todas as variáveis citadas acima são consideradas e uma comparação é realizada, a fim de assegurar que o novo elemento é inserido na ordem desejada. Assim,

%
\[\begin{array}{lll}
\multicolumn{3}{l}{{\mathcal{C}}((c',i')=c\mathit{.insert}(k,v)):=}\\
  & \multicolumn{2}{l}{\wedge\:{c'}_{size} := {c}_{size} + 1}\\
  & \multicolumn{2}{l}{\wedge\:i' := c.\textit{begin}()}\\
  & \wedge\: g_0 := &\!\!\!\!\textit{select}(c_k, i_{pos} = 0 \ldots i_{pos} = c_{size} - 1) > k \\
  & \wedge\: g_1 := &\!\!\!\!\textit{select}(c_k, i_{pos} = 0 \ldots i_{pos} = c_{size} - 1) == k \\
  & \multicolumn{2}{l}{\wedge\:{i'}_{pos} := \textit{ite}(g_0 \vee g_1, i_{pos}, c_{size})}\\
  & \wedge\: {c'}_k := &\!\!\!\!\textit{store}(c_k,{i'}_{pos} + 1, \textit{select}(c_k, {i'}_{pos})),\\
  & & \:\:\:\:\:\:\ldots,\\
  & & \textit{store}(c_k, c_{size}, \textit{select}(c_k, c_{size} - 1)))\\
  & \wedge\: {c'}_v := &\!\!\!\!\textit{store}(c_v,{i'}_{pos} + 1, \textit{select}(c_v, {i'}_{pos})),\\
  & & \:\:\:\:\:\:\ldots,\\
  & & \textit{store}(c_v, c_{size}, \textit{select}(c_v, c_{size} - 1)))\\
  & \multicolumn{2}{l}{\wedge\:{c'}_k := \textit{store}(c_k, {i'}_{pos}, k)}\\
  & \multicolumn{2}{l}{\wedge\:{c'}_v := \textit{store}(c_v, {i'}_{pos}, v)}\\
  & \multicolumn{2}{l}{\wedge\:{i'}_k := {c'}_k}\\
  & \multicolumn{2}{l}{\wedge\:{i'}_v := {c'}_v.}\\
\end{array}\]
%

Em casos onde chaves com vários valores associados são permitidos, a comparação feita será ignorada, caso seja verificado que já existe um elemento associado a respectiva chave analisada. Por fim, com o propósito de realizar uma exclusão, o método apagar, o qual é representado por $erase$($i$) onde $i$ é um \textit{iterator} que aponta para o elemento a ser excluído. Isso exclui o elemento apontado por $i$, movendo para trás todos os elementos seguidos pelo elemento que foi excluído. Deste modo,
%
\[\begin{array}{lll}
\multicolumn{3}{l}{{\mathcal{C}}((c',i')=c\mathit{.erase}(i)):=}\\
  & \multicolumn{2}{l}{\wedge\:{c'}_{size} := {c}_{size} - 1}\\
  & \wedge\: {c'}_k := &\!\!\!\!\textit{store}(c_k,{i'}_{pos}, \textit{select}(c_k, {i'}_{pos} + 1)),\\
  & & \:\:\:\:\:\:\ldots,\\
  & & \textit{store}(c_k, c_{size} - 2, \textit{select}(c_k, c_{size} - 1)))\\
  & \wedge\: {c'}_v := &\!\!\!\!\textit{store}(c_v,{i'}_{pos}, \textit{select}(c_v, {i'}_{pos} + 1)),\\
  & & \:\:\:\:\:\:\ldots,\\
  & & \textit{store}(c_v, c_{size} - 2, \textit{select}(c_v, c_{size} - 1)))\\
  & \multicolumn{2}{l}{\wedge\:{i'}_k := {c'}_k}\\
  & \multicolumn{2}{l}{\wedge\:{i'}_v := {c'}_v}\\
  & \multicolumn{2}{l}{\wedge\:{i'}_{pos} := {i}_{pos} + 1.}\\
\end{array}\]
%

Nota-se que tais modelos induzem implicitamente duas propriedades principais que possuem o objetivo de executar de forma correta as operações já mencionadas. A princípio a primeira propriedade se torna evidente quando $c_k$ e $c_v$ são considerados não vazios, isto é, $c_{size}$ também não é nulo para as operações de busca e exclusão de elementos. A segunda propriedade se torna evidente quando $i$ é considerado um \textit{iterator} do respectivo \textit{container} referido, isto é, dado um \textit{container} $c$ com os ponteiros bases $c_k$ e $c_v$, $i_k = c_k$ e $i_v = c_v$ são mantidos.% Na verdade, estas e outras propriedades específicas são tratadas em seus respectivos modelos operacionais conforme descrito no capítulo~\ref{chapter:smt-bmc}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Resumo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Neste capítulo, foi descrito como é realizado o processo de verificação de ESBMC$++$ junto com o modelo operacional (QtOM) de acordo como mostrado na Figura~\ref{figure:Fig2} e como subconjunto denominado \textit{Qt Container} que está integrado ao módulo \textit{Qt Core} do \textit{framework} Qt, sendo classificado em dois subgrupos: sequenciais e associativos, dependendo da estrutura de armazenamento implementada. Logo em seguida, é descrito como QtOM se utiliza de pré-condições para identificar partes das propriedades relacionadas ao \textit{framework} multiplataforma Qt, para que um determinado método ou função seja executado de forma correta e como QtOM usa pós-condições para garantir o mesmo comportamento de métodos ou funções de acordo com o apresentado nas bibliotecas nativas do \textit{framework} Qt~\cite{Qt15}. É descrito a linguaguem base formalizada por Ramalho \textit{et al.}~\cite{ECBS13}, mas adaptada com o objetivo de formular adequadamente a verificação de ambos tipos de \textit{containers} existentes. Por fim, os \textit{containers} sequenciais e associativos foram descritos de forma detalhada, a fim de ressaltar todos os metódos que constituem essas bibliotecas assim como, a forma que estão implementados a partir de uma transformação SSA. Como resultado, o conteúdo apresentado nesse capítulo fornece todo o embasamento necessário para compreensão da verificação de programas Qt/C$++$, utilizando o ESBMC$++$ como ferramenta base e um modelo operacional que utiliza pré e pós-condições para analisar o \textit{framework} em questão, enfatizando o seu subconjunto \textit{Qt Container}.