%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Método proposto}
\label{chapter:smt-bmc}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Este capítulo descreve todo o processo de verificação de ESBMC$++$ junto com QtOM, cujo torna possível a verificação de aplicações escritas em C$++$ que utilizam o \textit{framework} Qt. Vale ressaltar que ESBMC$++$ apenas suporta a verificação de aplicações ANSI-C/C$++$ e apesar das aplicações utilizarem C$++$ o \textit{framework} Qt possui suas bibliotecas nativas, as quais possui estruturas hierárquicas que inviabilizam a utilização de ESBMC$++$. Por fim, é descrito como QtOM se utiliza de pré e pós-condições para se obter o mesmo comportamento descrito na documentação oficial do \textit{framework}~\cite{Qt15}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introdução}
\label{sec:introdutions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Inicialmente, o \textit{parser} utilizado já havia sido mencionado na Seção~\ref{sec:arch} do Capítulo~\ref{chapter:background} e, nesta etapa, é onde o ESBMC$++$ transforma o código de entrada em uma árvore IRep, a qual, possui todas as informações necessárias para o processo de verificação e, ao fim desta etapa, o ESBMC++ identifica cada estrutura presente no respectivo programa. No entanto, o ESBMC$++$ suporta apenas a verificação de programas ANSI-C/C$++$. Apesar dos códigos analisados do Qt serem escritos em C$++$, suas bibliotecas nativas possuem muitas estruturas hierárquicas e complexas. Desta maneira, o processo de verificação para essas bibliotecas e suas respectivas implementações otimizadas afetariam de forma desnecessária as VCs, além do mais poderiam não conter qualquer afirmação a cerca de propriedades específicas, tornando a verificação uma tarefa inviável.

O uso do QtOM neste capítulo possui como objetivo solucionar o problema descrito acima, por ser uma representação simplificada, a qual considera a estrutura de cada biblioteca e suas respectivas classes associadas, incluindo atributos, assinaturas de métodos, protótipos de funções e assertivas, garantindo assim que cada propriedade seja formalmente verificada. Na verdade, existem muitas propriedades a serem verificadas como acesso de memória inválida, valores negativos que representam períodos de tempo, acesso à arquivos inexistentes e ponteiros nulos, juntamente com pré e pós-condições que são necessárias para executar corretamente os métodos do Qt. Vale ressaltar que QtOM é ligado de forma manual ao ESBMC$++$, logo no início do processo de verificação, como mostrado na Figura~\ref{figure:Fig2}. Desta forma, o QtOM pode auxiliar no processo de \textit{parser} durante a criação de uma representação intermediária em C$++$ que possui todas as assertivas indispensáveis para a verificação das propriedades mencionadas acima. Por fim, o fluxo de verificação segue de maneira tradicional.

\begin{figure}[htb]
  \centering
  \includegraphics[width=5.5in]{figuras/Fig2.pdf}
  \caption{Conectando QtOM a ESBMC$++$.}
  \label{figure:Fig2}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Pré-condições}
\label{sec:preconditions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ao se utilizar modelos limitados é possível diminuir a complexidade que é associada as árvores IRep. Desta forma, o ESBMC$++$ é capaz de construir árvores IRep de uma forma muito rápida, com baixa complexidade, mas que englobam todas as propriedades necessárias para a verificação dos programas desejados. Além disso, o uso de assertivas se torna indispensável para verificar propriedades relacionadas aos métodos do \textit{framework} multiplataforma Qt, assim como, as suas respectivas execuções que não são contempladas pelas bibliotecas padrões. Deste modo, tais assertivas são integrados aos respectivos métodos com o objetivo de detectar violações em relação ao uso incorreto do framework Qt. 

Em resumo, baseado na adição de assertivas, ESBMC$++$ é capaz de verificar propriedades específicas contidas em QtOM e identificar como pré-condições partes das propriedades relacionadas, ou seja, as propriedades que devem ser mantidas de forma que haja uma execução correta de um determinado método ou função. Por exemplo, a abordagem proposta pode verificar se um parâmetro, que representa uma determinada posição dentro de uma vetor é maior ou igual a zero.

De acordo com o fragmento de código mostrado na Figura~\ref{fig:Fig3} que pertence a aplicação chamada \textit{GeoMessage Simulator}. Esta aplicação fornece mensagens para componentes do sistema na plataforma ArcGIS~\cite{geomessage}. Como mostrado, o método $setFileName$() manipula uma pré-condição (veja linha $6$), onde $m\_inputFile$ é um objeto da classe \textit{QFile} que proporciona uma interface de leitura e escrita para se manipular arquivos~\cite{Qt15}. Ao ser definido um nome ao arquivo, o objeto $fileName$ da \textit{QString} não pode ser nulo. Desta forma, quando $setFileName$() é chamado, o ESBMC$++$ interpreta o seu comportamento de acordo com o implementado em QtOM como mostrado na Figura~\ref{fig:Fig4}.

\begin{figure}[htb]
\centering
\begin{minipage}{0.6\textwidth}
\begin{lstlisting}
QString loadSimulationFile( const QString &fileName )
{
   if(m_inputFile.isOpen())
     m_inputFile.close();
     
   m_inputFile.setFileName(fileName);
   
   //Check file for at least one message
   if( !doInitialRead() ) 
   {
      return QString(m_inputFile.fileName() + "is an empty message file");
   }
   else
   {
      return NULL;
   }
}
\end{lstlisting}
\end{minipage}
\caption{Fragmento de código da função \textit{loadSimulationFile} presente no benchmark Geomessage Simulator.}
\label{fig:Fig3}
\end{figure}

A Figura~\ref{fig:Fig4} mostra um trecho do modelo operacional correspondente à classe QFile com uma implementação de $setFileName$() (veja as linhas 5-10), onde apenas as pré-condições são verificadas. Em particular, se o objeto QString passado como um parâmetro não estiver vazio (veja a linha 6), a operação é válida e, consequentemente, a premissa assumida é considerada \textit{verdadeira}. Caso contrário, se uma operação incorreta for realizada, como uma \textit{string} vazia for passada como parâmetro, a premissa assumida é considerada \textit{falsa}. Nesse caso, o ESBMC$++$ retornaria um contraexemplo com todos os passos necessários para reproduzir a execução de tal violação, além de descrever o erro da respectiva premissa violada.\\


\begin{figure}[htb]
\centering
\begin{minipage}{0.5\textwidth}
\begin{lstlisting}
class QFile {
...
    QFile( const QString &name ) { ... }
    ...
    void setFileName( const QString &name ){
       __ESBMC_assert( !name.isEmpty(), "The string must not be empty" );
       __ESBMC_assert( !this->isOpen(), "The file must be closed" );
    }
    ...
};
\end{lstlisting}
\end{minipage}
\caption{Modelo operacional de $setFileName$() presente na classe QFile.}
\label{fig:Fig4}
\end{figure}

Do ponto de vista da verificação de software, existem métodos/funções que também não apresentam qualquer propriedade a ser verificada como aqueles cuja única finalidade é imprimir valores na tela. Dado que ESBMC$++$ realiza o processo verificação a nível de software ao invés de testar o hardware, a corretude a cerca do valor impresso na tela não foi abordado neste trabalho. Por fim, para tais métodos só existem assinaturas, de modo que o verificador proposto seja capaz de reconhecer a estrutura desejada para que durante o processo de análise seja construído uma árvores IRep confiável. No entanto, eles não apresentam qualquer modelagem (corpo de função), uma vez que não exista nenhuma propriedade a nível de software a ser verificada.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Pós-condições}
\label{sec:postconditions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Em aplicações reais existem métodos que não contêm apenas propriedades que serão tratadas como pré-condição, mas tambem serão considerados como pós-condições~\cite{monteiro2015,Musuvathi2002}. Por exemplo, de acordo com a documentação do Qt~\cite{Qt15}, a função $setFileName$ conforme descrita na Seção~\ref{sec:preconditions} não deve ser utilizada se o respectivo arquivo já estiver sendo utilizado, o que é verificado em seu código fonte a partir da estrutura $if$ presente nas linhas $3$ e $4$ visto na Figura~\ref{fig:Fig3}.

No entanto, a execução da instrução presente na linha $4$ (veja Fig.~\ref{fig:Fig3}) seria não determinística para o ESBMC$++$, assim como, a assertiva presente na linha $8$ do modelo operacional associado, como mostrado na Figura~\ref{fig:Fig4}, uma vez que não há como se afirmar se o respectivo arquivo está sendo utilizado ou não. Desta forma, é evidente que será necessário simular o comportamento do método $isOpen$() com o intuito de verificar de forma coerente as propriedades relacionadas com manipulação de arquivos. Como a classe \textit{QFile} indiretamente herda os métodos $open$() e $isOpen$(), a partir da classe \textit{QIODevice}, para simulações comportamentais desses métodos constrói-se um modelo operacional para \textit{QIODevice} conforme mostrado na Figura~\ref{fig:Fig5}.

\begin{figure}[htb]
\centering
\begin{minipage}{0.47\textwidth}
\begin{lstlisting}
class QIODevice {
    ...
    bool QIODevice::open(OpenMode mode){
       this->__openMode = mode;
       if (this->__openMode == NotOpen)
           this->__isOpen = false;
       this->__isOpen = true;
    }
    
    bool isOpen() const{
       return this->__isOpen;
    }
    ...
private:
    bool __isOpen;
    OpenMode __openMode;
    ...
};
\end{lstlisting}
\end{minipage}
\caption{Modelo operacional para os métodos $open$() e $isOpen$() na classe \textit{QIODevice}.}
\label{fig:Fig5}
\end{figure}

Por fim, todos os métodos que resultam em uma condição que deve ser mantida, a fim de permitir uma adequada execução de futuras instruções, devem apresentar uma simulação do seu comportamento. Consequentemente, um determinado modelo operacional deve seguir de forma rigorosa as especificações descritas na documentação oficial do \textit{framework}~\cite{Qt15} com o objetivo de se obter o mesmo comportamento, assim como, incluir mecanismos necessários à verificação do código. Como resultado, é necessário verificar o nível de equivalência entre o modelo operacional e a biblioteca original, com o intuito de se comparar o comportamento de ambos, tendo em vista que os modelos operacionais desenvolvidos são uma cópia simplificada das bibliotecas originais com todos os mecanismos necessários para a verificação do código~\cite{pereira2016}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Resumo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Neste capítulo, foi descrito como é realizado o processo de verificação com ESBMC$++$ junto com o modelo operacional proposto (QtOM) de acordo como mostrado na figura~\ref{figure:Fig2}, logo em seguida, é descrito como o modelo operacional proposto se utiliza de pré-condições para identificar partes das propriedades relacionadas ao \textit{framework} multiplataforma Qt, para que um determinado método ou função seja executado de forma correta. Por fim, descreve-se como QtOM usa pós-condições para garantir o mesmo comportamento de métodos ou funções, a serem analisados, em relação ao apresentado nas bibliotecas originais do \textit{framework}~\cite{Qt15}. Como resultado, o conteúdo apresentado nesse capítulo fornece todo o embasamento necessário para compreensão da verificação de programas Qt/C$++$, utilizando o ESBMC$++$ como ferramenta base e um modelo operacional que utiliza pré e pós-condições para analisar o \textit{framework} em questão.