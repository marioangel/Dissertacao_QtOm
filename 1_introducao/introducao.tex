%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introdução}
\label{chapter:introducao}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A atual disseminação com relação aos sistemas embarcados e sua devida importância está de acordo com a evolução dos componentes de hardware e softwares associados a eles. Na realidade, esses sistemas têm crescido em relação a sua robustez e complexidade, onde se torna visível o uso de processadores com vários núcleos, memórias compartilhadas escaláveis entre outros avançados recursos, de maneira a suprir o crescimento do poder computacional exigido, no qual pode-se obter por meio da combinação de linguagens de programação e \textit{frameworks}. Neste contexto, o Qt apresenta-se como um poderoso \textit{framework} multi-plataforma para dispostivos, o qual enfatiza a criação de interface para usuário (IU) e o desenvolvimento de aplicações gráficas~\cite{Qt15}. No entanto, como a complexidade de tais sistemas tende a crescer, o seu (bom) funcionamento se torna dependente do usuário; dependência está que também cresce de forma rápida. Em consequência, a confiabiliadade destes sistesmas torna-se algo de grande importância no processo de desenvolvimento de dispositivos comerciais e suas aplicações específicas.

Empresas de eletrônica de consumo cada vez mais investem em tempo e esforço para desenvolver alternativas rápidas e baratas referentes à verificação, com o objetivo de verificar a corretude de seus sistemas com o intuito de evitar perdas fincanceiras~\cite{Berard10}. Entre as alternativas já existentes, uma das mais eficiente e menos custosa é a abordagem da verificação de modelos~\cite{Clarke99} \textcolor{red}{Citar também o livro ``principles of model checking''}. Porém, existem muitos sistemas que não são possíveis de verificá-los de uma maneira automática devido à falta de suporte de certos tipos de linguagens e \textit{frameworks} por parte dos verificadores de código. Por exemplo, o verificador Java PathFinder é capaz de verificar códigos em Java baseado em byte-code~\cite{NASA07}, mas não há suporte a verificação (completa) de aplicações Java que utilizam o sistema operacional Android~\cite{MerweMV14}. Na realidade, esta verificação somente se torna possível se existir uma representação abstrata das bibliotecas associadas, denominada de modelo operacional(MO), que de forma conservadora aproxima-se a semântica usada pelo sistema a ser verificado~\cite{MerweTMV15}.

Este trabalho identifica as principais características do \textit{framework} Qt e propõe um modelo operacional (MO) que tem como propósito analisar e verificar as propriedades relacionadas de acordo com as suas funcionalidades. Os algoritmos desenvolvidos neste trabalho foram intregrados em uma ferramenta de verificação de modelos limitada (do inglês, \textit{Bounded Model Checking} - BMC) baseada nas teorias do módulo da satisfatibilidade (do inglês, satisfiability modulo theories - SMT), denominada \textit{Efficient SMT-based Context-Bounded Model Checker} (ESBMC$++$)~\cite{ECBS13} \textcolor{red}{Citar os artigos do TSE 2012 e ICSE 2011 do ESBMC}, a fim de verificar as específicas propriedades de programas em Qt/C++. A combinação entre ESBMC e MOs foi aplicada anteriormente para que se houvesse suporte a programas em C++, conforme descrito por Ramalho \textit{et al}.~\cite{ECBS13}. No entanto, na metodologia proposta, um MO é utilizado para identificar elementos do \textit{framework} Qt e verificar propriedades específicas relacionadas a essas estruturas por meio de pré e pós-condições \textcolor{red}{Citar um artigo que descreva estes termos}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Descrição do Problema}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Descrição

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Objetivos}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textcolor{red}{Deves descrever o objetivo geral e os específicos}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Contribuições}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

O trabalho é uma extensão de trabalhos já publicados anteriormente~\cite{monteiro2015}. O respectivo MO foi ampliado com o objetivo de incluir novas funcionalidades dos principais módulos do Qt, neste caso em particular, \textit{QtGui} e \textit{QtCore}. De fato, as principais contribuições aqui são:

\begin{itemize}
  \item Suportar \textit{containers} baseados em templates sequenciais e associativos;
  \item Integrar o QtOM \textcolor{red}{esta sigla não foi definida no texto anteriormente QtOM} ao processo de verificação de programas em C++ em verificadores que se encontram no estado da arte, neste caso, DIVINE~\cite{BBH13} e LLBMC~\cite{FalkeMS13};
  \item Fornecer suporte à verificação de duas aplicações baseadas em Qt denominadas Locomaps~\cite{locomaps} e Geomessage~\cite{geomessage}, respectivamente.
  \item Avaliar o desempenho de três solucionadores SMT(Z3~\cite{Z308}, Yices~\cite{Dutertre:cav2014} e Boolector~\cite{Boolector09}) sobre o conjunto de \textit{benchmarks} utilizados extensivamente e ampliado em relação ao trabalho anterior~\cite{monteiro2015} juntamente com a abordagem proposta. 
\end{itemize}

Por fim, em particular, foram incluídas representações para todas as bibliotecas relacionadas com as classes de Qt \textit{containers}. De acordo com o conhecimento atual em verificação de software, não há outro verificador que utilize modelos e se aplique técnicas BMC para verificar programas baseados no \textit{framework} Qt sobre dispositivos de eletrônica de consumo.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Trabalhos relacionados}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

De acordo com a atual literatura sobre verificação, não existe outro verificador disponível que seja capaz de verificar funcionalidades do \textit{framework} Qt. Ao contrário, as aplicações de eletrônica de consumo que utilizam este \textit{framework}, apresentam diversas propriedades que devem ser verificadas como estouro aritmético, segurança de ponteiros, limite de vetores e corretude no uso de \textit{containers}. Além disso, a verificação por meio de testes manuais é um processo árduo e custoso \textcolor{red}{Incluir referência}. Em resumo, a técnica BMC aplicada em verificação de software é usada em diversos verificadores~\cite{FalkeMS13,CBMC14,TSE12,WangBW14} e está se tornando cada vez mais popular, principalmente, devido ao aumento de solucionadores SMT cada vez mais sofisticados, os quais são baseados em eficientes solucionadores de satisfação Booleana (do inglês, Boolean Satisfiability - SAT)~\cite{Z308}.

\textcolor{red}{Precisas descrever o ESBMC++ aqui.}

Merz, Falke e Sinz~\cite{FalkeMS13} apresentam o \textit{Low-Level Bounded Model Checker} (LLBMC) como um verificador que utiliza modelos operacionais para verificar programas baseados em ANSI-C/C++. LLBMC também usa um compilador denominado \textit{low level virtual machine} (LLVM) que possui o objetivo de converter programas ANSI-C/C++ em uma representação intermediária utilizada pelo verificador. De forma semelhante, ao ESBMC$++$, Merz, Falke e Sinz também utilizam solucionadores SMT para analisar as condições de verificação. Contudo, diferente da abordagem aqui proposta, o LLBMC não suporta tratamento de exceção, o que acarreta numa verificação incorreta de programas reais escritos em C++, como por exemplo, programas baseados nas bibliotecas de template padrão (do inglês, Standard Template Libraries - STL). Vale ressaltar que a representação intermediária usado pelo LLVM perde algumas informações sobre a estrutura original dos respectivos programas em C++ , como por exemplo, as relações entre classes.

Barnat \textit{et al.} apresenta o DIVINE~\cite{BBH13} como um verificador de modelo de estado explícito para programas ANSI-C/C++ sequencias e multi-tarefas, o qual possui como objetivo principal verificar a segurança de propriedades de programas assíncronos e aqueles que utilizam memória compartilhada. DIVINE faz uso de um compilador conhecido como Clang~\cite{CLANG} como front-end, a fim de converter programas C++ em uma representação intermediária utilizada pelo LLVM, que logo em seguida realiza a verificação sobre o \textit{byte-code} produzido. Embora o DIVINE possua uma implementação de ANSI-C e das bibliotecas padrões do C++, o que lhe permite verificar programas desenvolvidos com essas linguaguens, o mesmo não possui qualquer suporte à representação disponibilizada pelo \textit{framework} Qt. De acordo com a abordagem proposta, DIVINE é capaz de criar um programa que possa ser interpretado totalmente pelo LLVM e então ser verificado logo em seguida.

Blanc, Groce e Kroening descrevem a verificação de programas em C++ que usam containers STL através de abstração predicada~\cite{Blanc07}, com o uso de dados de tipo abstrato sendo usados para realizar a verificação de STL ao invés de usar a implementação e o comportamento atual de componentes STL. Na verdade, eles mostram que a corretude pode ser realizada através de modelos operacionais, provando que a partir de condições prévias sobre operações, no mesmo modelo, acarreta em condições prévias nas bibliotecas padrões e pós-condições podem ser tão significativas quanto as condições originais. Tal abordagem é eficiente em encontrar erros triviais em programas em C++, mas que necessita de uma pesquisa mais profunda para evitar erros e operações enganosas ( isto é, ao envolver a modelagem de métodos internos). Vale ressaltar que, no presente trabalho, simulações do comportamento de certos métodos e funções superam o problema mencionado (visualizar Seção~\ref{sec:preconditions} ).

O C bounded model checker (CBMC) implementa a técnica BMC para programas ANSI-C/C++ através de solucionadores SAT/SMT~\cite{CBMC14}. Vale ressaltar que ESBMC foi construído em cima do CBMC, portanto, eles possuem processos de verificação semelhantes. Na verdade, CBMC pode processar programas usando a ferramenta goto-cc~\cite{Wintersteiger09} que compila o código fonte da aplicação para um GOTO-programs equivalente (ou seja, um gráfico do controle de fluxo), a partir de um modelo compátivel ao GCC. A partir de GOTO-programs CBMC cria uma árvore abstrata de sintaxe (AST) que é convertida em um formato independente da linguaguem interna usada para as etapas restantes. CBMC também utiliza duas funções recursivas ${\cal C}$ e ${\cal P}$ que registram as \emph{restrições} (ou seja, premissas e atribuições de variáveis) e as \emph{propriedades} (ou seja, condições de segurança e premissas definidas pelo o usuário), respectivamente. Este verificador cria de forma automática as condições de segurança que verificam a aritmética de under e overflow, violação no limite dos vetores e checagem de ponteiro nulo~\cite{Sites74}. Por fim, um gerador de condições de verificação (VCG), em seguida, criar condições de verificação (VCs) a partir das fórmulas criadas e os envia para um solucionador SAT/SMT. Embora CBMC esteje relacionado como susposto verificador de programas em C++, Ramalho \textit{et al.}~\cite{ECBS13} e Merz \textit{et al.}~\cite{Florian12} relatam que falhou ao verificar diversas aplicações simples em C++, o que também foi confirmado neste trabalho (visualizar Seção~\ref{sec:evaluation}).

Por fim, destaca-se que QtOM está completamente escrito em C++, o que facilita a integração dentro de processos de verificação de outros verificadores. No presente trabalho, QtOM não foi somente intregado a ESBMC$++$ mas também em DIVINE~\cite{BBH13} e LLBMC~\cite{FalkeMS13}, afim de obter uma avaliação mais justa sobre a abordagem proposta.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Organização da Dissertação}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Neste capítulo, inicialmente descreveram-se sobre o contexto que envolve o trabalho, a motivação, seus objetivos e além de terem sido apresentados trabalhos relacionados de acordo com a abordagem proposta com o intuito de juntar referências sobre o tema. Este trabalho está organizado da seguinte forma: 

\begin{itemize}
	\item O Capítulo 2, por sua vez, apresenta uma breve introdução sobre a arquitetura de ESBMC$++$ e satisfiability modulo theories(SMT) e também um resumo sobre o framework multiplataforma Qt;
	\item O Capítulo 3, descreve uma representação simplificada das bibliotecas Qt, nomeado como Qt Operational Model(QtOM), que também aborda pré e pós-condições.
	\item O Capítulo 4, descreve a implementação formal de Qt Containers associativos e sequencias desenvolvidos de forma detalhada.
	\item O Capítulo 5, descreve os resultados experimentais realizados usando benchmarks Qt/C++ e também a verificação de duas aplicações baseadas em Qt, onde a primeira mostra imagens de satélites, terrenos, mapas de ruas e Tiled Map Service(TMS) panning entre outras características~\cite{locomaps} e a segunda aplicação cria um broadcast User Datagram Protocol(UDP) baseado em arquivos XML.
	\item Por fim, o Capítulo 6 apresenta as conclusões, destacando a importância da criação de um modelo para verificar aplicações que utilizam framework Qt, assim como, os trabalhos futuros também são descritos.
\end{itemize}