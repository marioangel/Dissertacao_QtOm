%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introdução}
\label{chapter:introducao}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A atual disseminação com relação aos sistemas embarcados e sua devida importância está de acordo com a evolução dos componentes de hardware e softwares associados a eles~\cite{eps2009}. Na realidade, esses sistemas têm crescido em relação a sua robustez e complexidade, onde se torna visível o uso de processadores com vários núcleos, memórias compartilhadas escaláveis entre outros avançados recursos, de maneira a suprir o crescimento do poder computacional exigido. Neste contexto, o Qt apresenta-se como um poderoso \textit{framework} multi-plataforma para sistemas embarcados, o qual enfatiza a criação de interface para usuário (IU) e o desenvolvimento de aplicações gráficas~\cite{Qt15}. No entanto, como a complexidade de tais sistemas tende a crescer, o seu (bom) funcionamento se torna dependente do usuário; dependência está que também cresce de forma rápida. Em consequência, a confiabiliadade destes sistesmas torna-se algo de grande importância no processo de desenvolvimento de dispositivos comerciais e suas aplicações específicas.

Empresas de eletrônica de consumo cada vez mais investem em tempo e esforço para desenvolver alternativas rápidas e baratas referentes à verificação, com o objetivo de verificar a corretude de seus sistemas com o intuito de evitar perdas fincanceiras~\cite{Berard10}. Entre as alternativas já existentes, uma das mais eficiente e menos custosa é a abordagem da verificação de modelos~\cite{Clarke99}~\cite{Christel08}. Porém, existem muitos sistemas que não são possíveis de verificá-los de uma maneira automática devido à falta de suporte de certos tipos de linguagens e \textit{frameworks} por parte dos verificadores de código. Por exemplo, o verificador \textit{Java PathFinder} é capaz de verificar códigos em Java baseado em \textit{bytecode}~\cite{NASA07}, mas não há suporte a verificação (completa) de aplicações Java que utilizam o sistema operacional Android~\cite{MerweMV14}. Na realidade, esta verificação somente se torna possível se existir uma representação abstrata das bibliotecas associadas, denominada de modelo operacional (MO), que de forma conservadora aproxima-se a semântica usada pelo sistema a ser verificado~\cite{MerweTMV15}.

Este trabalho identifica as principais características do \textit{framework} Qt e propõe um modelo operacional (MO) que tem como propósito analisar e verificar as propriedades relacionadas de acordo com as suas funcionalidades. Os algoritmos desenvolvidos neste trabalho foram intregrados em uma ferramenta de verificação de modelos limitada (do inglês, \textit{Bounded Model Checking} - BMC) baseada nas teorias do módulo da satisfatibilidade (do inglês, \textit{satisfiability modulo theories} - SMT), denominada \textit{Efficient SMT-based Context-Bounded Model Checker} (ESBMC$++$)~\cite{ECBS13}~\cite{ICSE11}~\cite{TSE12}, a fim de verificar propriedades específicas de programas escritos em Qt/C++. A combinação entre ESBMC e MOs foi aplicada anteriormente para fornecer suporte à verificação de programas escritos em C++, conforme descrito por Ramalho \textit{et al.}~\cite{ECBS13}. No entanto, na metodologia proposta, um MO é utilizado para identificar elementos do \textit{framework} Qt e verificar propriedades específicas relacionadas a estas estruturas por meio de pré e pós-condições~\cite{monteiro2015}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Descrição do Problema}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A dependência do usuário com relação ao funcionamento correto de sistemas embarcados, está aumentando rapidamente. Isto ocorre, devido à importância que esses sistemas adquiriram ao longo do tempo de acordo com a evolução dos componentes de hardware e softwares associados a estes. Como consequência, o nível de robustez e complexidade desses sistemas também têm aumentado, exigindo processadores mais eficientes, memórias com maiores capacidades e interfaces de usuário que garantem ao usuário destes sistemas uma boa usabilidade, assim como, uma boa confiabilidade também, aspecto que possui grande importância no processo de desenvolvimento destes sistemas. A partir desse contexto, o \textit{framework} multiplataforma Qt surge como forte e eficaz ferramenta, o qual possui como foco principal a criação de interface para usuário (IU)~\cite{Qt15}, assim como, o desenvolvimento de aplicações para dipositivos móveis(ou não). Por isso, o problema a ser tratado por essa dissertação está relacionado à encontrar falhas de funcionamento nessas aplicações para dipositivos móveis(ou não), garantindo a confiabilidade destes sistemas evitando perdas financeiras.

Cada vez mais, empresas que possui como atividade principal o desenvolvimento de sistemas embarcados, designam seu tempo e esforços a desenvolver novas alternativas de verificação que sejam rápidas, baratas e possuam como objetivo garantir a confiabilidade dos sistemas desenvolvidos, assim como, evitar grandes perdas financeiras~\cite{Berard10}. Entre as técnicas existentes, a abordagem através da verificação de modelos é considerada a de menor custo e a mais eficiente mas nem sempre é possível utiliza-la devido as particularidades que cada sistema possui~\cite{Clarke99, Christel08}. Por exemplo, o verificador \textit{ESBMC-GPU} é capaz somente de verificar códigos de GPUs que se utilizam da linguaguem CUDA, a partir de uma representação abstrata das bibliotecas associadas a ele mas não possui suporte a qualquer outro tipo de linguaguem utilizada por outros tipos de GPUs~\cite{pereira2016}. Como já mencionada, a representação abstrata têm como objetivo aproximar-se de forma semântica ao usada pelo sistema a ser analisado~\cite{MerweTMV15}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Objetivos}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

O objetivo geral deste trabalhar é aplicar as técnicas de verificação utilizando modelos operacionais para checar aplicações que utilizam o \textit{framework} Qt, usando ferramentas de verificação, a fim de validar a cobertura e o comportamento do modelo operacional proposto em relação ao \textit{framework} utilizado.

Os objetivos específicos são listados a seguir:

\begin{itemize}
  \item Desenvolver uma implementação simplificada que oferece estritamente o mesmo comportamento do \textit{framework} Qt com foco na verificação de suas propriedades.
  \item Verificar o acesso de memória inválida, valores que especificam o tempo, acesso à arquivos ausentes, ponteiros nulos, manipulação de cadeia de caracteres (\textit{strings}), uso de \textit{containers}, entre outras propriedades de interesse para aplicações Qt.
  \item Aplicar a metodologia de verificação proposta em aplicações reais que utilizam o \textit{framework} Qt.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Trabalhos relacionados}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

De acordo com a atual literatura sobre verificação, não existe outro verificador disponível que seja capaz de verificar funcionalidades do \textit{framework} Qt. Ao contrário, as aplicações de eletrônica de consumo que utilizam este \textit{framework}, apresentam diversas propriedades que devem ser verificadas como estouro aritmético, segurança de ponteiros, limite de vetores e corretude no uso de \textit{containers}. A técnica BMC aplicada em verificação de software é usada em diversos verificadores~\cite{TSE12,FalkeMS13,CBMC14,WangBW14} e está se tornando cada vez mais popular, principalmente, devido ao aumento de solucionadores SMT cada vez mais sofisticados, os quais são baseados em eficientes solucionadores de satisfação Booleana (do inglês, \textit{Boolean Satisfiability} - SAT)~\cite{Z308}.

Ramalho \textit{et al.}~\cite{ECBS13} apresentam o \textit{Efficient SMT-Based Context-Bounded Model Checker} (ESBMC) como um verificador de modelos limitados para verificar programas em C$++$, sendo denominado ESBMC$++$. ESBMC$++$ utiliza seus modelos operacionais para oferecer suporte à verificação das características mais complexas que a linguagem oferece, como \textit{containers} e tratamento de exceção. Vale ressaltar que os modelos usados são uma representação abstrata das bibliotecas padrões do C++, que de forma conservadora se aproximam semanticamente das bibliotecas originais. ESBMC$++$ se utiliza disso para codificar as condições de verificação criadas usando diferentes teorias de base apoiadas por solucionadores SMT.

Merz, Falke e Sinz~\cite{FalkeMS13} apresentam o \textit{Low-Level Bounded Model Checker} (LLBMC) como um verificador que utiliza modelos operacionais para verificar programas baseados em ANSI-C/C++. LLBMC também usa um compilador denominado \textit{low level virtual machine} (LLVM) que possui o objetivo de converter programas ANSI-C/C++ em uma representação intermediária utilizada pelo verificador. De forma semelhante ao ESBMC$++$, Merz, Falke e Sinz também utilizam solucionadores SMT para analisar as condições de verificação. Contudo, diferente da abordagem aqui proposta, o LLBMC não suporta tratamento de exceção, o que acarreta numa verificação incorreta de programas reais escritos em C++, como por exemplo, programas baseados em \textit{Standard Template Libraries} (STL). Vale ressaltar que a representação intermediária usado pelo LLVM perde algumas informações sobre a estrutura original dos respectivos programas em C++ , como por exemplo, as relações entre classes.

Barnat \textit{et al.} apresentam o DIVINE~\cite{BBH13} como um verificador de modelo de estado explícito para programas ANSI-C/C++ sequencias e multi-tarefas, o qual possui como objetivo principal verificar a segurança de propriedades de programas assíncronos e aqueles que utilizam memória compartilhada. DIVINE faz uso de um compilador denominado Clang~\cite{CLANG} como \textit{front-end}, a fim de converter programas C++ em uma representação intermediária utilizada por LLVM, que logo em seguida realiza a verificação sobre o \textit{bytecode} produzido. Embora o DIVINE possua uma implementação de ANSI-C e das bibliotecas padrões do C++, o que lhe permite verificar programas desenvolvidos com essas linguaguens, o mesmo não possui qualquer suporte à representação disponibilizada pelo \textit{framework} Qt. De acordo com essa abordagem, o DIVINE é capaz de criar um programa que possa ser interpretado totalmente por LLVM e logo em seguida ser verificado.

Blanc, Groce e Kroening descrevem a verificação de programas em C++ que usam \textit{containers} STL através de abstração de predicados~\cite{Blanc07}, com o uso de tipo de dados abstrato, sendo usados para realizar a verificação de STL ao invés de usar a implementação real dos componentes STL. Na verdade, os autores mostram que a corretude pode ser realizada através de modelos operacionais, provando que a partir de condições prévias sobre operações, no mesmo modelo, acarreta em condições prévias nas bibliotecas padrões, e pós-condições podem ser tão significativas quanto as condições originais. Tal abordagem é eficiente em encontrar erros triviais em programas em C++, mas que necessita de uma pesquisa mais profunda para evitar erros e operações enganosas (isto é, ao envolver a modelagem de métodos internos). Vale ressaltar que, no presente trabalho, simulações do comportamento de certos métodos e funções superam o problema mencionado (ver Seção~\ref{sec:preconditions}).

O \textit{C Bounded Model Checker} (CBMC) implementa a técnica BMC para programas ANSI-C/C++ por meio de solucionadores SAT/SMT~\cite{CBMC14}. Vale ressaltar que o ESBMC foi construído a partir do CBMC, portanto, ambos verificadores possuem processos de verificação parecidos. Na verdade, o CBMC processa programas C/C++ usando a ferramenta goto-cc~\cite{Wintersteiger09}, a qual compila o código fonte da aplicação para um \textit{GOTO-program} equivalente (ou seja, um grafo de fluxo de controle), a partir de um modelo compátivel ao GCC. A partir de \textit{GOTO-program}, o CBMC cria uma árvore abstrata de sintaxe (do inglês, \textit{Abstract Syntax Tree} - AST) que é convertida em um formato independente da linguaguem interna usada para as etapas restantes. O CBMC também utiliza duas funções recursivas $\mathcal{C}$ e $\mathcal{P}$ que registram as \emph{restrições} (ou seja, premissas e atribuições de variáveis) e as \emph{propriedades} (ou seja, condições de segurança e premissas definidas pelo o usuário), respectivamente. Este verificador cria de forma automática as condições de segurança que verificam o estouro aritmético, violação no limite dos vetores e checagem de ponteiro nulo~\cite{Sites74}. Por fim, um gerador de condições de verificação (do inglês, \textit{Verification Condition Geneator} - VCG) cria condições de verificação (do inglês, Verification Conditions - VCs) a partir das fórmulas criadas e os envia para um solucionador SAT/SMT. Embora o CBMC esteja relacionado como susposto verificador de programas em C++, Ramalho \textit{et al.}~\cite{ECBS13} e Merz \textit{et al.}~\cite{Florian12} relatam que o CBMC falha ao verificar diversas aplicações simples em C++, o que também foi confirmado neste trabalho (ver Seção~\ref{sec:evaluation}).

Finalmente, destaca-se que o QtOM foi completamente escrito na linguagem de programação C++, o que facilita a integração dentro de processos de verificação de outros verificadores. No presente trabalho, o QtOM não foi somente intregado ao ESBMC$++$, mas também no DIVINE~\cite{BBH13} e LLBMC~\cite{FalkeMS13}, afim de obter uma avaliação sobre a abordagem proposta.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Contribuições}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Este trabalho é uma extensão de artigos já publicados anteriormente~\cite{ECBS13,monteiro2015}. O respectivo modelo operacional (MO) proposto foi ampliado com o objetivo de incluir novas funcionalidades dos principais módulos do Qt, neste caso em particular, \textit{QtGui} e \textit{QtCore}. De fato, as principais contribuições aqui são:

\begin{itemize}
  \item Suportar \textit{containers} baseados em templates sequenciais e associativos;
  \item Integrar o modelo operacional proposto denominado QtOM ao processo de verificação de programas em C++ em verificadores que se encontram no estado da arte, neste caso, DIVINE~\cite{BBH13} e LLBMC~\cite{FalkeMS13};
  \item Fornecer suporte à verificação de duas aplicações reais que utilizam Qt denominadas Locomaps~\cite{locomaps} e Geomessage~\cite{geomessage}, respectivamente.
  \item Avaliar o desempenho de três solucionadores SMT (Z3~\cite{Z308}, Yices~\cite{Dutertre:cav2014} e Boolector~\cite{Boolector09}) juntamente com a abordagem proposta utilizando o conjunto de \textit{benchmarks} extensivamente revisado e ampliado em relação ao trabalho anterior~\cite{monteiro2015}. 
\end{itemize}

Por fim, foram incluídas representações para todas as bibliotecas relacionadas as classes de Qt \textit{containers}. De acordo com o conhecimento atual em verificação de software, não há outro verificador que utilize modelos e se aplique técnicas BMC para verificar programas baseados no \textit{framework} Qt sobre dispositivos de eletrônica de consumo.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Organização}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Neste capítulo, inicialmente descreveram-se sobre o contexto que envolve o trabalho, a motivação, seus objetivos, além de terem sido apresentados trabalhos relacionados de acordo com a abordagem proposta, com o intuito de descrever referências sobre o tema proposto. Este trabalho está organizado da seguinte forma: 

\begin{itemize}
	\item O Capítulo 2 apresenta uma breve introdução sobre a arquitetura do ESBMC$++$ e as teorias do módulo da satisfatibilidade (SMT), além de descrever um resumo sobre o \textit{framework} multiplataforma Qt;
	\item O Capítulo 3 descreve uma representação simplificada das bibliotecas Qt, nomeado como Qt \textit{Operational Model} (QtOM), que também aborda pré e pós-condições.
	\item O Capítulo 4 descreve a implementação formal de Qt \textit{Containers} associativos e sequencias desenvolvidos de forma detalhada.
	\item O Capítulo 5 descreve os resultados experimentais realizados usando \textit{benchmarks} Qt/C++ e também a verificação de duas aplicações baseadas em Qt, onde a primeira apresenta imagens de satélites, terrenos, mapas de ruas e \textit{Tiled Map Service} (TMS) \textit{panning} entre outras características~\cite{locomaps} e a segunda aplicação cria um \textit{broadcast User Datagram Protocol} (UDP) baseado em arquivos XML.
	\item Por fim, o Capítulo 6 apresenta as conclusões, destacando a importância da criação de um modelo para verificar aplicações que utilizam o \textit{framework} Qt, assim como, os trabalhos futuros também são descritos.
\end{itemize}