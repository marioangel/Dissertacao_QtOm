%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introdução}
\label{chapter:introducao}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A atual disseminação dos sistemas embarcados e sua devida importância está de acordo com a evolução dos componentes de hardware e software associados a eles~\cite{eps2009}. Na realidade, esses sistemas têm crescido em relação a sua robustez e complexidade, onde se torna visível o uso de processadores com vários núcleos e memórias compartilhadas escaláveis, de maneira a suprir o crescimento do poder computacional exigido. Neste contexto, Qt apresenta-se como um poderoso \textit{framework} multiplataforma para sistemas embarcados que enfatiza a criação de interface para usuário (IU) e o desenvolvimento de aplicações gráficas~\cite{Qt15}. No entanto, a dependência do usuário em relação ao bom funcionamento de tais sistemas tem crescido de maneira rápida, assim como as suas complexidades. Em consequência, a confiabiliadade e a segurança de tais sistesmas torna-se algo de grande importância no processo de desenvolvimento de dispositivos comerciais e suas aplicações específicas.

Empresas de eletrônica de consumo cada vez investem mais em tempo e esforço para desenvolver alternativas rápidas e baratas referentes à verificação, com o objetivo de verificar a corretude de seus sistemas com o intuito de evitar perdas fincanceiras~\cite{Berard10}. Entre as alternativas já existentes, uma das mais eficiente e menos custosa é a abordagem da verificação de modelos~\cite{Clarke99}~\cite{Christel08}. Porém, existem muitos sistemas que não são possíveis de verificá-los de uma maneira automática devido à falta de suporte de certos tipos de linguagens e \textit{frameworks} por parte dos verificadores de código. Por exemplo, o verificador \textit{Java PathFinder} é capaz de verificar códigos em Java baseado em \textit{bytecode}~\cite{NASA07}, mas não há suporte a verificação (completa) de aplicações Java que utilizam o sistema operacional Android~\cite{MerweMV14}. Na realidade, esta verificação somente se torna possível se existir uma representação abstrata das bibliotecas associadas, denominada de modelo operacional (MO) que, de forma conservadora, aproxima-se a semântica usada pelo sistema a ser verificado~\cite{MerweTMV15}.

Essa dissertação identifica as principais características do \textit{framework} Qt e propõe um modelo operacional (MO) que tem como propósito analisar e verificar as propriedades relacionadas de acordo com as suas funcionalidades. Vale ressaltar, que este trabalho é uma extensão de artigos já publicados anteriormente~\cite{ECBS13,monteiro2015} e os algoritmos desenvolvidos neste trabalho foram intregrados em uma ferramenta de verificação de modelos limitada (do inglês, \textit{Bounded Model Checking} - BMC) baseada nas teorias do módulo da satisfatibilidade (do inglês, \textit{satisfiability modulo theories} - SMT), denominada \textit{Efficient SMT-based Context-Bounded Model Checker} (ESBMC$++$)~\cite{ECBS13}~\cite{ICSE11}~\cite{TSE12}, a fim de verificar propriedades específicas de programas escritos em Qt/C++. 

A combinação entre ESBMC e MOs foi aplicada anteriormente para fornecer suporte à verificação de programas escritos em C++, conforme descrito por Ramalho \textit{et al.}~\cite{ECBS13}. No entanto, no método proposta, um MO é utilizado para identificar elementos do \textit{framework} Qt e verificar propriedades específicas relacionadas a estas estruturas por meio de pré e pós-condições~\cite{monteiro2015}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Descrição do Problema}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A dependência do usuário com relação ao funcionamento correto de sistemas embarcados tem aumentando rapidamente. Isto ocorre, devido a importância que esses sistemas adquiriram ao longo do tempo de acordo com a evolução dos componentes de hardware e software associados a estes. Como consequência, erros tendem a se tornar presente nesses sistemas, devido a problemas no projeto ou na implementação de falhas no hardware/software desenvolvido, mesmo que a detecção de falhas e a proteção do hardware possam ter sido analisados e modelados de forma rigorosa. O nível de robustez e complexidade desses sistemas também têm aumentado, exigindo processadores mais eficientes, memórias com maiores capacidades e interfaces de usuário que garantem ao usuário destes sistemas uma boa usabilidade e confiabilidade, aspecto que possui grande importância no processo de desenvolvimento destes sistemas. A partir desse contexto, o \textit{framework} multiplataforma Qt surge como forte e eficaz ferramenta, qual possui como foco principal a criação de interface para usuário (IU) e o desenvolvimento de aplicações para dipositivos móveis (ou não)~\cite{Qt15}. Por isso, o problema a ser tratado por essa dissertação está relacionado a detecção de falhas em aplicações para dispositivos móveis (ou não) que utilizam o \textit{framework} multiplataforma Qt. Cada aplicação requer métodos de programação específicos e a natureza crítica dessas aplicações necessitam de mecanismos de proteção de falha e certificação, a fim de reduzir as falhas existentes, garantindo assim a confiabilidade destes sistemas, evitando perdas de recursos financeiros, recursos humanos, recursos logísticos e otimizando o tempo de desenvolvimento.

Cada vez mais, empresas que possuem como atividade principal o desenvolvimento de sistemas embarcados, designam seu tempo e esforços a desenvolver novas alternativas de verificação que sejam rápidas, baratas e possuam como objetivo garantir a confiabilidade dos sistemas desenvolvidos~\cite{Berard10}. Entre as técnicas existentes, a abordagem através da verificação de modelos é considerada a de menor custo e a mais eficiente, mas nem sempre é possível utilizá-la devido as particularidades que cada sistema possui~\cite{Clarke99, Christel08}. Por exemplo, o verificador \textit{ESBMC-GPU} é capaz somente de verificar códigos de GPUs que se utilizam da linguaguem CUDA, a partir de uma representação abstrata (modelo operacional) das bibliotecas associadas a ele, mas não possui suporte a qualquer outro tipo de linguaguem utilizada por outros tipos de GPUs~\cite{pereira2016,pereira2016journal}. A representação abstrata (modelo operacional) utilizado em \textit{ESBMC-GPU} têm como objetivo aproximar-se de forma semântica ao sistema real analisado~\cite{MerweTMV15}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Objetivos}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

O objetivo geral dessa dissertação é aplicar a técnica de verificação de modelos limitados para verificar aplicações que utilizam o \textit{framework} multiplataforma Qt, usando ferramentas de verificação e compiladores C++ para validar a taxa de cobertura, o tempo de verificação e o nível de conformidade do método proposto, quando comparado com a documentação do \textit{framework} Qt.

Os objetivos específicos são listados a seguir:

\begin{itemize}
  \item Modularizar e extender o suporte do modelo operacional proposto que oferece estritamente o mesmo comportamento do \textit{framework} Qt com foco na verificação de suas propriedades.
  \item Verificar as aplicações que utilizam o \textit{framework} Qt contidas no conjunto de \textit{benckmarks} com foco em duas propriedades base: acesso de memória e manipulação de dados.
  \item Aplicar a metodologia de verificação proposta em aplicações reais que utilizam o \textit{framework} Qt.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Contribuições}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

O respectivo modelo operacional (MO) proposto, denominado QtOM, foi ampliado com o objetivo de incluir novas funcionalidades dos principais módulos do Qt, neste caso em particular, \textit{QtGui} e \textit{QtCore}. De fato, as principais contribuições aqui são:

\begin{itemize}
  \item Estruturar os módulos \textit{QtGui} e \textit{QtCore} de acordo com a estrutura utilizada pelo \textit{framework} Qt.
  \item Corrigir o erros existentes nos \textit{containers} baseados em templates associativos e extender o suporte de QtOM para \textit{containers} baseados em templates sequenciais.
  \item Avaliar o desempenho de três solucionadores SMT (Z3~\cite{Z308}, Yices~\cite{Dutertre:cav2014} e Boolector~\cite{Boolector09}) juntamente com a abordagem proposta utilizando o conjunto de \textit{benchmarks} (esbmc--qt) extensivamente revisado e ampliado em relação ao trabalho anterior~\cite{monteiro2015}.
  \item Integrar QtOM ao processo de verificação de programas em C++ de verificadores que se encontram no estado da arte, neste caso, DIVINE~\cite{BBH13} e LLBMC~\cite{FalkeMS13}
  \item Fornecer suporte à verificação de duas aplicações reais que utilizam o \textit{framework} Qt denominadas Locomaps~\cite{locomaps} e Geomessage~\cite{geomessage}, respectivamente.
  \item Avaliar o modelo operacional proposto com o intuito de analisar seu nível de conformidade em relação ao \textit{framework} Qt.

\end{itemize}

Por fim, de acordo com o conhecimento atual em verificação de software, não há outro verificador que utilize modelos operacionais e se aplique técnicas BMC para verificar programas que utilizam o \textit{framework} Qt sobre dispositivos de eletrônica de consumo.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Trabalhos relacionados}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

De acordo com a atual literatura sobre verificação, não existe outro verificador disponível que seja capaz de verificar as funcionalidades do \textit{framework} Qt. Ao contrário, as aplicações de eletrônica de consumo que utilizam este \textit{framework} apresentam diversas propriedades que devem ser verificadas, como estouro aritmético, segurança de ponteiros, limite de vetores e corretude no uso de \textit{containers}. A técnica BMC aplicada em verificação de software é usada em diversos verificadores~\cite{TSE12,FalkeMS13,CBMC14,WangBW14} e está se tornando cada vez mais popular, principalmente, devido ao aumento de solucionadores SMT cada vez mais sofisticados, os quais são baseados em eficientes solucionadores de satisfação Booleana (do inglês, \textit{Boolean Satisfiability} - SAT)~\cite{Z308}. Entretanto, também é conhecido que não existe homogeneidade em relação a abordagem de implementação e respectivas heurísticas em solucionadores SMT~\cite{TSE12}, sendo assim, os resultados obtidos através da verificação que se utiliza solucionadores SMT é fortemente afetado por esta limitação.

Ramalho \textit{et al.}~\cite{ECBS13} apresentam o \textit{Efficient SMT-Based Context-Bounded Model Checker} (ESBMC) como um verificador de modelos limitados para verificar programas em C$++$, sendo denominado ESBMC$++$. ESBMC$++$ utiliza seus modelos operacionais para oferecer suporte a verificação das características mais complexas que a linguagem oferece, como \textit{containers} e tratamento de exceção. Vale ressaltar que os modelos operacionais usados são uma representação abstrata das bibliotecas padrões do C++, que de forma conservadora se aproximam semanticamente das bibliotecas originais. ESBMC$++$ se utiliza disso para codificar as condições de verificação criadas usando diferentes teorias de base apoiadas por solucionadores SMT. Entretanto, os modelos operacionais usados possuem limitações, tendo como exemplo a verificação de métodos estáticos que se encontra incompleta e ao se utilizar listas dentro de listas.

Merz, Falke e Sinz~\cite{FalkeMS13} apresentam o \textit{Low-Level Bounded Model Checker} (LLBMC) como um verificador que utiliza modelos operacionais para verificar programas baseados em ANSI-C/C++. LLBMC também usa um compilador denominado \textit{low level virtual machine} (LLVM) que possui o objetivo de converter programas ANSI-C/C++ em uma representação intermediária utilizada pelo verificador. De forma semelhante ao ESBMC$++$, Merz, Falke e Sinz também utilizam solucionadores SMT para analisar as condições de verificação. Contudo, diferente da abordagem aqui proposta, o LLBMC não suporta tratamento de exceção, o que acarreta numa verificação incorreta de programas reais escritos em C++, como por exemplo, programas baseados em \textit{Standard Template Libraries} (STL). Vale ressaltar que a representação intermediária usado pelo LLVM perde algumas informações sobre a estrutura original dos respectivos programas em C++ , como por exemplo, as relações entre classes.

Barnat \textit{et al.} apresentam o DIVINE~\cite{BBH13} como um verificador de modelo de estado explícito para programas ANSI-C/C++ sequenciais e multi-tarefas, o qual possui como objetivo principal verificar a segurança de propriedades de programas assíncronos e aqueles que utilizam memória compartilhada. DIVINE faz uso de um compilador denominado Clang~\cite{CLANG} como \textit{front-end}, a fim de converter programas C++ em uma representação intermediária utilizada por LLVM, que logo em seguida realiza a verificação sobre o \textit{bytecode} produzido. DIVINE também possui uma implementação de ANSI-C e das bibliotecas padrões do C++, o que lhe permite verificar programas desenvolvidos com essas linguaguens. De acordo com essa abordagem, DIVINE é capaz de criar um programa que possa ser interpretado totalmente por LLVM e logo em seguida ser verificado. Contudo, a abordagem utilizada por DIVINE é custosa, pois cria uma grande quantidade de estados explícitos, os quais todos seram analisados pela ferramenta em seu processo de verificação, sendo assim, DIVINE também possui um alto tempo de verificação.

Blanc, Groce e Kroening descrevem a verificação de programas em C++ que usam \textit{containers} STL através de abstração de predicados~\cite{Blanc07}, com o uso de tipo de dados abstrato, sendo usados para realizar a verificação de STL ao invés de usar a implementação real dos componentes STL. Na verdade, os autores mostram que a corretude pode ser realizada através de modelos operacionais, provando que a partir de condições prévias sobre operações, no mesmo modelo, acarreta em condições prévias nas bibliotecas padrões, e pós-condições podem ser tão significativas quanto as condições originais. Tal abordagem é eficiente em encontrar erros triviais em programas em C++, mas que necessita de uma pesquisa mais profunda para evitar erros e operações enganosas (isto é, ao envolver a modelagem de métodos internos). Vale ressaltar que, no presente trabalho, simulações do comportamento de certos métodos e funções superam o problema mencionado (ver Seção~\ref{sec:preconditions}).

O \textit{C Bounded Model Checker} (CBMC) implementa a técnica BMC para programas ANSI-C/C++ por meio de solucionadores SAT/SMT~\cite{CBMC14}. Vale ressaltar que o ESBMC foi construído a partir do CBMC, portanto, ambos verificadores possuem processos de verificação parecidos. Na verdade, o CBMC processa programas C/C++ usando a ferramenta goto-cc~\cite{Wintersteiger09}, a qual compila o código fonte da aplicação para um programa GOTO equivalente (ou seja, um grafo de fluxo de controle), a partir de um modelo compátivel ao GCC. A partir do programa GOTO criado, o CBMC cria uma árvore abstrata de sintaxe (do inglês, \textit{Abstract Syntax Tree} - AST) que é convertida em um formato independente da linguaguem interna usada para as etapas restantes. O CBMC também utiliza duas funções recursivas $\mathcal{C}$ e $\mathcal{P}$ que registram as \emph{restrições} (ou seja, premissas e atribuições de variáveis) e as \emph{propriedades} (ou seja, condições de segurança e premissas definidas pelo o usuário), respectivamente. Este verificador cria de forma automática as condições de segurança que verificam o estouro aritmético, violação no limite dos vetores e checagem de ponteiro nulo~\cite{Sites74}. Por fim, um gerador de condições de verificação (do inglês, \textit{Verification Condition Geneator} - VCG) cria condições de verificação (do inglês, Verification Conditions - VCs) a partir das fórmulas criadas e os envia para um solucionador SAT/SMT. Embora o CBMC esteja relacionado como susposto verificador de programas em C++, Ramalho \textit{et al.}~\cite{ECBS13} e Merz \textit{et al.}~\cite{Florian12} relatam que o CBMC falha ao verificar diversas aplicações simples em C++, o que também foi confirmado neste trabalho (ver Seção~\ref{sec:evaluation}).

Monteiro \textit{et al.}~\cite{monteiro2015} descreve um modelo operacional que integrado a ESBMC++ consegue verificar uma aplicação que utiliza o \textit{framework} Qt. O modelo operacional descrito se encontra em estado inicial e não moduralizado por tipos e classes mas oferece um suporte a containers sequenciais. Vale ressaltar que no presente trabalho, o modelo operacional descrito é extendido e são corrigidos alguns erros existentes a nível de modelo operacional (\textit{i.e}, \textit{namespace} implementado em classe inapropiada e a criação de rotinas de verificação em métodos estáticos).

Finalmente, destaca-se que QtOM foi completamente escrito na linguagem de programação C++, o que facilita a integração dentro de processos de verificação de outros verificadores, logo, QtOM não foi somente intregado ao processo de verificação de ESBMC$++$ mas também ao de DIVINE~\cite{BBH13} e LLBMC~\cite{FalkeMS13}, afim de obter uma avaliação sobre a abordagem proposta.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Organização}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Neste capítulo, inicialmente descreveram-se sobre o contexto que envolve o trabalho, a motivação, seus objetivos, além de terem sido apresentados trabalhos relacionados de acordo com a abordagem proposta, com o intuito de descrever referências sobre o tema proposto. Este trabalho está organizado da seguinte forma: 

\begin{itemize}
	\item O Capítulo 2 apresenta uma breve introdução sobre a arquitetura do ESBMC$++$ e as teorias do módulo da satisfatibilidade (SMT), além de descrever um resumo sobre o \textit{framework} multiplataforma Qt;
	\item O Capítulo 3 descreve uma representação simplificada das bibliotecas Qt, nomeado como Qt \textit{Operational Model} (QtOM), que também aborda pré e pós-condições.
	\item O Capítulo 4 descreve a implementação formal de Qt \textit{Containers} associativos e sequencias desenvolvidos de forma detalhada.
	\item O Capítulo 5 descreve os resultados experimentais realizados usando \textit{benchmarks} Qt/C++ e também a verificação de duas aplicações baseadas em Qt, onde a primeira apresenta imagens de satélites, terrenos, mapas de ruas e \textit{Tiled Map Service} (TMS) \textit{panning} entre outras características~\cite{locomaps} e a segunda aplicação cria um \textit{broadcast User Datagram Protocol} (UDP) baseado em arquivos XML.
	\item Por fim, o Capítulo 6 apresenta as conclusões, destacando a importância da criação de um modelo para verificar aplicações que utilizam o \textit{framework} Qt, assim como, os trabalhos futuros também são descritos.
\end{itemize}